(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[641],{3454:function(module,__unused_webpack_exports,__webpack_require__){"use strict";var ref,ref1;module.exports=(null==(ref=__webpack_require__.g.process)?void 0:ref.env)&&"object"==typeof(null==(ref1=__webpack_require__.g.process)?void 0:ref1.env)?__webpack_require__.g.process:__webpack_require__(7663)},7663:function(module){!function(){var e={229:function(e){var r,n,u,t=e.exports={};function defaultSetTimout(){throw Error("setTimeout has not been defined")}function defaultClearTimeout(){throw Error("clearTimeout has not been defined")}function runTimeout(e){if(r===setTimeout)return setTimeout(e,0);if((r===defaultSetTimout||!r)&&setTimeout)return r=setTimeout,setTimeout(e,0);try{return r(e,0)}catch(t1){try{return r.call(null,e,0)}catch(t){return r.call(this,e,0)}}}!function(){try{r="function"==typeof setTimeout?setTimeout:defaultSetTimout}catch(e){r=defaultSetTimout}try{n="function"==typeof clearTimeout?clearTimeout:defaultClearTimeout}catch(e1){n=defaultClearTimeout}}();var i=[],o=!1,a=-1;function cleanUpNextTick(){o&&u&&(o=!1,u.length?i=u.concat(i):a=-1,i.length&&drainQueue())}function drainQueue(){if(!o){var e=runTimeout(cleanUpNextTick);o=!0;for(var t=i.length;t;){for(u=i,i=[];++a<t;)u&&u[a].run();a=-1,t=i.length}u=null,o=!1,function(e){if(n===clearTimeout)return clearTimeout(e);if((n===defaultClearTimeout||!n)&&clearTimeout)return n=clearTimeout,clearTimeout(e);try{n(e)}catch(t1){try{return n.call(null,e)}catch(t){return n.call(this,e)}}}(e)}}function Item(e,t){this.fun=e,this.array=t}function noop(){}t.nextTick=function(e){var t=Array(arguments.length-1);if(arguments.length>1)for(var r=1;r<arguments.length;r++)t[r-1]=arguments[r];i.push(new Item(e,t)),1!==i.length||o||runTimeout(drainQueue)},Item.prototype.run=function(){this.fun.apply(null,this.array)},t.title="browser",t.browser=!0,t.env={},t.argv=[],t.version="",t.versions={},t.on=noop,t.addListener=noop,t.once=noop,t.off=noop,t.removeListener=noop,t.removeAllListeners=noop,t.emit=noop,t.prependListener=noop,t.prependOnceListener=noop,t.listeners=function(e){return[]},t.binding=function(e){throw Error("process.binding is not supported")},t.cwd=function(){return"/"},t.chdir=function(e){throw Error("process.chdir is not supported")},t.umask=function(){return 0}}},t={};function __nccwpck_require__(r){var n=t[r];if(void 0!==n)return n.exports;var i=t[r]={exports:{}},o=!0;try{e[r](i,i.exports,__nccwpck_require__),o=!1}finally{o&&delete t[r]}return i.exports}__nccwpck_require__.ab="//";var r=__nccwpck_require__(229);module.exports=r}()},9008:function(module,__unused_webpack_exports,__webpack_require__){module.exports=__webpack_require__(3121)},3566:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){"use strict";__webpack_require__.d(__webpack_exports__,{E:function(){return motion}});var isValidProp,AnimationType,BoundingBoxDimension,AnimationType1,BoundingBoxDimension1,react=__webpack_require__(7294);let MotionConfigContext=(0,react.createContext)({transformPagePoint:p=>p,isStatic:!1,reducedMotion:"never"}),MotionContext=(0,react.createContext)({}),PresenceContext_PresenceContext=(0,react.createContext)(null),isBrowser="undefined"!=typeof document,useIsomorphicLayoutEffect=isBrowser?react.useLayoutEffect:react.useEffect,LazyContext=(0,react.createContext)({strict:!1});function isRefObject(ref){return"object"==typeof ref&&Object.prototype.hasOwnProperty.call(ref,"current")}function isVariantLabel(v){return"string"==typeof v||Array.isArray(v)}function isAnimationControls(v){return"object"==typeof v&&"function"==typeof v.start}let variantProps=["initial","animate","exit","whileHover","whileDrag","whileTap","whileFocus","whileInView"];function isControllingVariants(props){return isAnimationControls(props.animate)||variantProps.some(name=>isVariantLabel(props[name]))}function isVariantNode(props){return Boolean(isControllingVariants(props)||props.variants)}function variantLabelsAsDependency(prop){return Array.isArray(prop)?prop.join(" "):prop}let createDefinition=propNames=>({isEnabled:props=>propNames.some(name=>!!props[name])}),featureDefinitions={measureLayout:createDefinition(["layout","layoutId","drag"]),animation:createDefinition(["animate","exit","variants","whileHover","whileTap","whileFocus","whileDrag","whileInView"]),exit:createDefinition(["exit"]),drag:createDefinition(["drag","dragControls"]),focus:createDefinition(["whileFocus"]),hover:createDefinition(["whileHover","onHoverStart","onHoverEnd"]),tap:createDefinition(["whileTap","onTap","onTapStart","onTapCancel"]),pan:createDefinition(["onPan","onPanStart","onPanSessionStart","onPanEnd"]),inView:createDefinition(["whileInView","onViewportEnter","onViewportLeave"])};function useConstant(init){let ref=(0,react.useRef)(null);return null===ref.current&&(ref.current=init()),ref.current}let globalProjectionState={hasAnimatedSinceResize:!0,hasEverUpdated:!1},id=1,LayoutGroupContext=(0,react.createContext)({});class VisualElementHandler extends react.Component{getSnapshotBeforeUpdate(){let{visualElement,props}=this.props;return visualElement&&visualElement.setProps(props),null}componentDidUpdate(){}render(){return this.props.children}}let SwitchLayoutGroupContext=(0,react.createContext)({}),motionComponentSymbol=Symbol.for("motionComponentSymbol"),lowercaseSVGElements=["animate","circle","defs","desc","ellipse","g","image","line","filter","marker","mask","metadata","path","pattern","polygon","polyline","rect","stop","svg","switch","symbol","text","tspan","use","view"];function isSVGComponent(Component){if("string"!=typeof Component||Component.includes("-"));else if(lowercaseSVGElements.indexOf(Component)>-1||/[A-Z]/.test(Component))return!0;return!1}let scaleCorrectors={},transformPropOrder=["transformPerspective","x","y","z","translateX","translateY","translateZ","scale","scaleX","scaleY","rotate","rotateX","rotateY","rotateZ","skew","skewX","skewY"],transformProps=new Set(transformPropOrder);function isForcedMotionValue(key,{layout,layoutId}){return transformProps.has(key)||key.startsWith("origin")||(layout||void 0!==layoutId)&&(!!scaleCorrectors[key]||"opacity"===key)}let isMotionValue=value=>!!(null==value?void 0:value.getVelocity),translateAlias={x:"translateX",y:"translateY",z:"translateZ",transformPerspective:"perspective"},sortTransformProps=(a,b)=>transformPropOrder.indexOf(a)-transformPropOrder.indexOf(b);function isCSSVariable(key){return key.startsWith("--")}let getValueAsType=(value,type)=>type&&"number"==typeof value?type.transform(value):value,clamp=(min,max)=>v=>Math.max(Math.min(v,max),min),sanitize=v=>v%1?Number(v.toFixed(5)):v,floatRegex=/(-)?([\d]*\.?[\d])+/g,colorRegex=/(#[0-9a-f]{6}|#[0-9a-f]{3}|#(?:[0-9a-f]{2}){2,4}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))/gi,singleColorRegex=/^(#[0-9a-f]{3}|#(?:[0-9a-f]{2}){2,4}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))$/i;function isString(v){return"string"==typeof v}let createUnitType=unit=>({test:v=>isString(v)&&v.endsWith(unit)&&1===v.split(" ").length,parse:parseFloat,transform:v=>`${v}${unit}`}),degrees=createUnitType("deg"),percent=createUnitType("%"),px=createUnitType("px"),vh=createUnitType("vh"),vw=createUnitType("vw"),progressPercentage=Object.assign(Object.assign({},percent),{parse:v=>percent.parse(v)/100,transform:v=>percent.transform(100*v)}),number={test:v=>"number"==typeof v,parse:parseFloat,transform:v=>v},alpha=Object.assign(Object.assign({},number),{transform:clamp(0,1)}),scale=Object.assign(Object.assign({},number),{default:1}),type_int_int={...number,transform:Math.round},numberValueTypes={borderWidth:px,borderTopWidth:px,borderRightWidth:px,borderBottomWidth:px,borderLeftWidth:px,borderRadius:px,radius:px,borderTopLeftRadius:px,borderTopRightRadius:px,borderBottomRightRadius:px,borderBottomLeftRadius:px,width:px,maxWidth:px,height:px,maxHeight:px,size:px,top:px,right:px,bottom:px,left:px,padding:px,paddingTop:px,paddingRight:px,paddingBottom:px,paddingLeft:px,margin:px,marginTop:px,marginRight:px,marginBottom:px,marginLeft:px,rotate:degrees,rotateX:degrees,rotateY:degrees,rotateZ:degrees,scale:scale,scaleX:scale,scaleY:scale,scaleZ:scale,skew:degrees,skewX:degrees,skewY:degrees,distance:px,translateX:px,translateY:px,translateZ:px,x:px,y:px,z:px,perspective:px,transformPerspective:px,opacity:alpha,originX:progressPercentage,originY:progressPercentage,originZ:px,zIndex:type_int_int,fillOpacity:alpha,strokeOpacity:alpha,numOctaves:type_int_int};function buildHTMLStyles(state,latestValues,options,transformTemplate){let{style,vars,transform,transformKeys,transformOrigin}=state;transformKeys.length=0;let hasTransform=!1,hasTransformOrigin=!1,transformIsNone=!0;for(let key in latestValues){let value=latestValues[key];if(isCSSVariable(key)){vars[key]=value;continue}let valueType=numberValueTypes[key],valueAsType=getValueAsType(value,valueType);if(transformProps.has(key)){if(hasTransform=!0,transform[key]=valueAsType,transformKeys.push(key),!transformIsNone)continue;value!==(valueType.default||0)&&(transformIsNone=!1)}else key.startsWith("origin")?(hasTransformOrigin=!0,transformOrigin[key]=valueAsType):style[key]=valueAsType}if(!latestValues.transform&&(hasTransform||transformTemplate?style.transform=function({transform,transformKeys},{enableHardwareAcceleration=!0,allowTransformNone=!0},transformIsDefault,transformTemplate){let transformString="";for(let key of(transformKeys.sort(sortTransformProps),transformKeys))transformString+=`${translateAlias[key]||key}(${transform[key]}) `;return enableHardwareAcceleration&&!transform.z&&(transformString+="translateZ(0)"),transformString=transformString.trim(),transformTemplate?transformString=transformTemplate(transform,transformIsDefault?"":transformString):allowTransformNone&&transformIsDefault&&(transformString="none"),transformString}(state,options,transformIsNone,transformTemplate):style.transform&&(style.transform="none")),hasTransformOrigin){let{originX="50%",originY="50%",originZ=0}=transformOrigin;style.transformOrigin=`${originX} ${originY} ${originZ}`}}let createHtmlRenderState=()=>({style:{},transform:{},transformKeys:[],transformOrigin:{},vars:{}});function copyRawValuesOnly(target,source,props){for(let key in source)isMotionValue(source[key])||isForcedMotionValue(key,props)||(target[key]=source[key])}function useHTMLProps(props,visualState,isStatic){let htmlProps={},style=function(props,visualState,isStatic){let styleProp=props.style||{},style={};return copyRawValuesOnly(style,styleProp,props),Object.assign(style,function({transformTemplate},visualState,isStatic){return(0,react.useMemo)(()=>{let state=createHtmlRenderState();return buildHTMLStyles(state,visualState,{enableHardwareAcceleration:!isStatic},transformTemplate),Object.assign({},state.vars,state.style)},[visualState])}(props,visualState,isStatic)),props.transformValues?props.transformValues(style):style}(props,visualState,isStatic);return props.drag&&!1!==props.dragListener&&(htmlProps.draggable=!1,style.userSelect=style.WebkitUserSelect=style.WebkitTouchCallout="none",style.touchAction=!0===props.drag?"none":`pan-${"x"===props.drag?"y":"x"}`),htmlProps.style=style,htmlProps}let validMotionProps=new Set(["initial","style","values","variants","transition","transformTemplate","transformValues","custom","inherit","layout","layoutId","layoutDependency","onLayoutAnimationStart","onLayoutAnimationComplete","onLayoutMeasure","onBeforeLayoutMeasure","onAnimationStart","onAnimationComplete","onUpdate","onDragStart","onDrag","onDragEnd","onMeasureDragConstraints","onDirectionLock","onDragTransitionEnd","drag","dragControls","dragListener","dragConstraints","dragDirectionLock","dragSnapToOrigin","_dragX","_dragY","dragElastic","dragMomentum","dragPropagation","dragTransition","onHoverStart","onHoverEnd","layoutScroll","whileInView","onViewportEnter","onViewportLeave","viewport","whileTap","onTap","onTapStart","onTapCancel","animate","exit","variants","whileHover","whileTap","whileFocus","whileDrag","whileInView","onPan","onPanStart","onPanSessionStart","onPanEnd"]);function isValidMotionProp(key){return validMotionProps.has(key)}let shouldForward=key=>!isValidMotionProp(key);try{(isValidProp=require("@emotion/is-prop-valid").default)&&(shouldForward=key=>key.startsWith("on")?!isValidMotionProp(key):isValidProp(key))}catch(_a){}function calcOrigin(origin,offset,size){return"string"==typeof origin?origin:px.transform(offset+size*origin)}let dashKeys={offset:"stroke-dashoffset",array:"stroke-dasharray"},camelKeys={offset:"strokeDashoffset",array:"strokeDasharray"};function buildSVGAttrs(state,{attrX,attrY,originX,originY,pathLength,pathSpacing=1,pathOffset=0,...latest},options,transformTemplate){buildHTMLStyles(state,latest,options,transformTemplate),state.attrs=state.style,state.style={};let{attrs,style,dimensions}=state;attrs.transform&&(dimensions&&(style.transform=attrs.transform),delete attrs.transform),dimensions&&(void 0!==originX||void 0!==originY||style.transform)&&(style.transformOrigin=function(dimensions,originX,originY){let pxOriginX=calcOrigin(originX,dimensions.x,dimensions.width),pxOriginY=calcOrigin(originY,dimensions.y,dimensions.height);return`${pxOriginX} ${pxOriginY}`}(dimensions,void 0!==originX?originX:.5,void 0!==originY?originY:.5)),void 0!==attrX&&(attrs.x=attrX),void 0!==attrY&&(attrs.y=attrY),void 0!==pathLength&&function(attrs,length,spacing=1,offset=0,useDashCase=!0){attrs.pathLength=1;let keys=useDashCase?dashKeys:camelKeys;attrs[keys.offset]=px.transform(-offset);let pathLength=px.transform(length),pathSpacing=px.transform(spacing);attrs[keys.array]=`${pathLength} ${pathSpacing}`}(attrs,pathLength,pathSpacing,pathOffset,!1)}let createSvgRenderState=()=>({...createHtmlRenderState(),attrs:{}});function useSVGProps(props,visualState){let visualProps=(0,react.useMemo)(()=>{let state=createSvgRenderState();return buildSVGAttrs(state,visualState,{enableHardwareAcceleration:!1},props.transformTemplate),{...state.attrs,style:{...state.style}}},[visualState]);if(props.style){let rawStyles={};copyRawValuesOnly(rawStyles,props.style,props),visualProps.style={...rawStyles,...visualProps.style}}return visualProps}let camelToDash=str=>str.replace(/([a-z])([A-Z])/g,"$1-$2").toLowerCase();function renderHTML(element,{style,vars},styleProp,projection){for(let key in Object.assign(element.style,style,projection&&projection.getProjectionStyles(styleProp)),vars)element.style.setProperty(key,vars[key])}let camelCaseAttributes=new Set(["baseFrequency","diffuseConstant","kernelMatrix","kernelUnitLength","keySplines","keyTimes","limitingConeAngle","markerHeight","markerWidth","numOctaves","targetX","targetY","surfaceScale","specularConstant","specularExponent","stdDeviation","tableValues","viewBox","gradientTransform","pathLength"]);function renderSVG(element,renderState,_styleProp,projection){for(let key in renderHTML(element,renderState,void 0,projection),renderState.attrs)element.setAttribute(camelCaseAttributes.has(key)?key:camelToDash(key),renderState.attrs[key])}function scrapeMotionValuesFromProps(props){let{style}=props,newValues={};for(let key in style)(isMotionValue(style[key])||isForcedMotionValue(key,props))&&(newValues[key]=style[key]);return newValues}function scrape_motion_values_scrapeMotionValuesFromProps(props){let newValues=scrapeMotionValuesFromProps(props);for(let key in props)if(isMotionValue(props[key])){let targetKey="x"===key||"y"===key?"attr"+key.toUpperCase():key;newValues[targetKey]=props[key]}return newValues}function resolveVariantFromProps(props,definition,custom,currentValues={},currentVelocity={}){return"function"==typeof definition&&(definition=definition(void 0!==custom?custom:props.custom,currentValues,currentVelocity)),"string"==typeof definition&&(definition=props.variants&&props.variants[definition]),"function"==typeof definition&&(definition=definition(void 0!==custom?custom:props.custom,currentValues,currentVelocity)),definition}let isKeyframesTarget=v=>Array.isArray(v),isCustomValue=v=>Boolean(v&&"object"==typeof v&&v.mix&&v.toValue),resolveFinalValueInKeyframes=v=>isKeyframesTarget(v)?v[v.length-1]||0:v;function resolveMotionValue(value){let unwrappedValue=isMotionValue(value)?value.get():value;return isCustomValue(unwrappedValue)?unwrappedValue.toValue():unwrappedValue}let makeUseVisualState=config=>(props,isStatic)=>{let context=(0,react.useContext)(MotionContext),presenceContext=(0,react.useContext)(PresenceContext_PresenceContext),make=()=>(function({scrapeMotionValuesFromProps,createRenderState,onMount},props,context,presenceContext){let state={latestValues:function(props,context,presenceContext,scrapeMotionValues){let values={},motionValues=scrapeMotionValues(props);for(let key in motionValues)values[key]=resolveMotionValue(motionValues[key]);let{initial,animate}=props,isControllingVariants$1=isControllingVariants(props),isVariantNode$1=isVariantNode(props);context&&isVariantNode$1&&!isControllingVariants$1&&!1!==props.inherit&&(void 0===initial&&(initial=context.initial),void 0===animate&&(animate=context.animate));let isInitialAnimationBlocked=!!presenceContext&&!1===presenceContext.initial;isInitialAnimationBlocked=isInitialAnimationBlocked||!1===initial;let variantToSet=isInitialAnimationBlocked?animate:initial;if(variantToSet&&"boolean"!=typeof variantToSet&&!isAnimationControls(variantToSet)){let list=Array.isArray(variantToSet)?variantToSet:[variantToSet];list.forEach(definition=>{let resolved=resolveVariantFromProps(props,definition);if(!resolved)return;let{transitionEnd,transition,...target}=resolved;for(let key in target){let valueTarget=target[key];if(Array.isArray(valueTarget)){let index=isInitialAnimationBlocked?valueTarget.length-1:0;valueTarget=valueTarget[index]}null!==valueTarget&&(values[key]=valueTarget)}for(let key1 in transitionEnd)values[key1]=transitionEnd[key1]})}return values}(props,context,presenceContext,scrapeMotionValuesFromProps),renderState:createRenderState()};return onMount&&(state.mount=instance=>onMount(props,instance,state)),state})(config,props,context,presenceContext);return isStatic?make():useConstant(make)},svgMotionConfig={useVisualState:makeUseVisualState({scrapeMotionValuesFromProps:scrape_motion_values_scrapeMotionValuesFromProps,createRenderState:createSvgRenderState,onMount(props,instance,{renderState,latestValues}){try{renderState.dimensions="function"==typeof instance.getBBox?instance.getBBox():instance.getBoundingClientRect()}catch(e){renderState.dimensions={x:0,y:0,width:0,height:0}}buildSVGAttrs(renderState,latestValues,{enableHardwareAcceleration:!1},props.transformTemplate),renderSVG(instance,renderState)}})},htmlMotionConfig={useVisualState:makeUseVisualState({scrapeMotionValuesFromProps:scrapeMotionValuesFromProps,createRenderState:createHtmlRenderState})};function addDomEvent(target,eventName,handler,options={passive:!0}){return target.addEventListener(eventName,handler,options),()=>target.removeEventListener(eventName,handler)}function useDomEvent(ref,eventName,handler,options){(0,react.useEffect)(()=>{let element=ref.current;if(handler&&element)return addDomEvent(element,eventName,handler,options)},[ref,eventName,handler,options])}function isMouseEvent(event){return"undefined"!=typeof PointerEvent&&event instanceof PointerEvent?!("mouse"!==event.pointerType):event instanceof MouseEvent}function isTouchEvent(event){let hasTouches=!!event.touches;return hasTouches}(AnimationType=AnimationType1||(AnimationType1={})).Animate="animate",AnimationType.Hover="whileHover",AnimationType.Tap="whileTap",AnimationType.Drag="whileDrag",AnimationType.Focus="whileFocus",AnimationType.InView="whileInView",AnimationType.Exit="exit";let defaultPagePoint={pageX:0,pageY:0};function extractEventInfo(event,pointType="page"){return{point:isTouchEvent(event)?function(e,pointType="page"){let primaryTouch=e.touches[0]||e.changedTouches[0],point=primaryTouch||defaultPagePoint;return{x:point[pointType+"X"],y:point[pointType+"Y"]}}(event,pointType):function(point,pointType="page"){return{x:point[pointType+"X"],y:point[pointType+"Y"]}}(event,pointType)}}let wrapHandler=(handler,shouldFilterPrimaryPointer=!1)=>{let listener=event=>handler(event,extractEventInfo(event));return shouldFilterPrimaryPointer?event=>{let isMouseEvent=event instanceof MouseEvent,isPrimaryPointer=!isMouseEvent||isMouseEvent&&0===event.button;isPrimaryPointer&&listener(event)}:listener},supportsPointerEvents=()=>isBrowser&&null===window.onpointerdown,supportsTouchEvents=()=>isBrowser&&null===window.ontouchstart,supportsMouseEvents=()=>isBrowser&&null===window.onmousedown,mouseEventNames={pointerdown:"mousedown",pointermove:"mousemove",pointerup:"mouseup",pointercancel:"mousecancel",pointerover:"mouseover",pointerout:"mouseout",pointerenter:"mouseenter",pointerleave:"mouseleave"},touchEventNames={pointerdown:"touchstart",pointermove:"touchmove",pointerup:"touchend",pointercancel:"touchcancel"};function getPointerEventName(name){if(supportsPointerEvents());else if(supportsTouchEvents())return touchEventNames[name];else if(supportsMouseEvents())return mouseEventNames[name];return name}function addPointerEvent(target,eventName,handler,options){return addDomEvent(target,getPointerEventName(eventName),wrapHandler(handler,"pointerdown"===eventName),options)}function usePointerEvent(ref,eventName,handler,options){return useDomEvent(ref,getPointerEventName(eventName),handler&&wrapHandler(handler,"pointerdown"===eventName),options)}function createLock(name){let lock=null;return()=>{let openLock=()=>{lock=null};return null===lock&&(lock=name,openLock)}}let globalHorizontalLock=createLock("dragHorizontal"),globalVerticalLock=createLock("dragVertical");function getGlobalLock(drag){let lock=!1;if("y"===drag)lock=globalVerticalLock();else if("x"===drag)lock=globalHorizontalLock();else{let openHorizontal=globalHorizontalLock(),openVertical=globalVerticalLock();openHorizontal&&openVertical?lock=()=>{openHorizontal(),openVertical()}:(openHorizontal&&openHorizontal(),openVertical&&openVertical())}return lock}function isDragActive(){let openGestureLock=getGlobalLock(!0);return!openGestureLock||(openGestureLock(),!1)}function createHoverEvent(visualElement,isActive,callback){return(event,info)=>{!(!isMouseEvent(event)||isDragActive())&&(visualElement.animationState&&visualElement.animationState.setActive(AnimationType1.Hover,isActive),callback&&callback(event,info))}}let isNodeOrChild=(parent,child)=>!!child&&(parent===child||isNodeOrChild(parent,child.parentElement));function useUnmountEffect(callback){return(0,react.useEffect)(()=>()=>callback(),[])}let combineFunctions=(a,b)=>v=>b(a(v)),pipe=(...transformers)=>transformers.reduce(combineFunctions);var process=__webpack_require__(3454);let env=(void 0===process||process.env,"production"),warned=new Set,observerCallbacks=new WeakMap,observers=new WeakMap,fireObserverCallback=entry=>{let callback=observerCallbacks.get(entry.target);callback&&callback(entry)},fireAllObserverCallbacks=entries=>{entries.forEach(fireObserverCallback)},thresholdNames={some:0,all:1};function useIntersectionObserver(shouldObserve,state,visualElement,{root,margin:rootMargin,amount="some",once}){(0,react.useEffect)(()=>{if(!shouldObserve||!visualElement.current)return;let options={root:null==root?void 0:root.current,rootMargin,threshold:"number"==typeof amount?amount:thresholdNames[amount]},intersectionCallback=entry=>{let{isIntersecting}=entry;if(state.isInView===isIntersecting||(state.isInView=isIntersecting,once&&!isIntersecting&&state.hasEnteredView))return;isIntersecting&&(state.hasEnteredView=!0),visualElement.animationState&&visualElement.animationState.setActive(AnimationType1.InView,isIntersecting);let props=visualElement.getProps(),callback=isIntersecting?props.onViewportEnter:props.onViewportLeave;callback&&callback(entry)};return function(element,options,callback){let rootInteresectionObserver=function({root,...options}){let lookupRoot=root||document;observers.has(lookupRoot)||observers.set(lookupRoot,{});let rootObservers=observers.get(lookupRoot),key=JSON.stringify(options);return rootObservers[key]||(rootObservers[key]=new IntersectionObserver(fireAllObserverCallbacks,{root,...options})),rootObservers[key]}(options);return observerCallbacks.set(element,callback),rootInteresectionObserver.observe(element),()=>{observerCallbacks.delete(element),rootInteresectionObserver.unobserve(element)}}(visualElement.current,options,intersectionCallback)},[shouldObserve,root,rootMargin,amount])}function useMissingIntersectionObserver(shouldObserve,state,visualElement,{fallback=!0}){(0,react.useEffect)(()=>{if(shouldObserve&&fallback){if("production"!==env){var message,element;message="IntersectionObserver not available on this device. whileInView animations will trigger on mount.",warned.has(message)||(console.warn(message),element&&console.warn(element),warned.add(message))}requestAnimationFrame(()=>{state.hasEnteredView=!0;let{onViewportEnter}=visualElement.getProps();onViewportEnter&&onViewportEnter(null),visualElement.animationState&&visualElement.animationState.setActive(AnimationType1.InView,!0)})}},[shouldObserve])}let makeRenderlessComponent=hook=>props=>(hook(props),null),gestureAnimations={inView:makeRenderlessComponent(function({visualElement,whileInView,onViewportEnter,onViewportLeave,viewport={}}){let state=(0,react.useRef)({hasEnteredView:!1,isInView:!1}),shouldObserve=Boolean(whileInView||onViewportEnter||onViewportLeave);viewport.once&&state.current.hasEnteredView&&(shouldObserve=!1);let useObserver="undefined"==typeof IntersectionObserver?useMissingIntersectionObserver:useIntersectionObserver;useObserver(shouldObserve,state.current,visualElement,viewport)}),tap:makeRenderlessComponent(function({onTap,onTapStart,onTapCancel,whileTap,visualElement}){let isPressing=(0,react.useRef)(!1),cancelPointerEndListeners=(0,react.useRef)(null),eventOptions={passive:!(onTapStart||onTap||onTapCancel||onPointerDown)};function removePointerEndListener(){cancelPointerEndListeners.current&&cancelPointerEndListeners.current(),cancelPointerEndListeners.current=null}function checkPointerEnd(){return removePointerEndListener(),isPressing.current=!1,visualElement.animationState&&visualElement.animationState.setActive(AnimationType1.Tap,!1),!isDragActive()}function onPointerUp(event,info){checkPointerEnd()&&(isNodeOrChild(visualElement.current,event.target)?onTap&&onTap(event,info):onTapCancel&&onTapCancel(event,info))}function onPointerCancel(event,info){checkPointerEnd()&&onTapCancel&&onTapCancel(event,info)}function onPointerDown(event,info){removePointerEndListener(),!isPressing.current&&(isPressing.current=!0,cancelPointerEndListeners.current=pipe(addPointerEvent(window,"pointerup",onPointerUp,eventOptions),addPointerEvent(window,"pointercancel",onPointerCancel,eventOptions)),visualElement.animationState&&visualElement.animationState.setActive(AnimationType1.Tap,!0),onTapStart&&onTapStart(event,info))}usePointerEvent(visualElement,"pointerdown",onTap||onTapStart||onTapCancel||whileTap?onPointerDown:void 0,eventOptions),useUnmountEffect(removePointerEndListener)}),focus:makeRenderlessComponent(function({whileFocus,visualElement}){let{animationState}=visualElement,onFocus=()=>{animationState&&animationState.setActive(AnimationType1.Focus,!0)},onBlur=()=>{animationState&&animationState.setActive(AnimationType1.Focus,!1)};useDomEvent(visualElement,"focus",whileFocus?onFocus:void 0),useDomEvent(visualElement,"blur",whileFocus?onBlur:void 0)}),hover:makeRenderlessComponent(function({onHoverStart,onHoverEnd,whileHover,visualElement}){usePointerEvent(visualElement,"pointerenter",onHoverStart||whileHover?createHoverEvent(visualElement,!0,onHoverStart):void 0,{passive:!onHoverStart}),usePointerEvent(visualElement,"pointerleave",onHoverEnd||whileHover?createHoverEvent(visualElement,!1,onHoverEnd):void 0,{passive:!onHoverEnd})})};function usePresence(){let context=(0,react.useContext)(PresenceContext_PresenceContext);if(null===context)return[!0,null];let{isPresent,onExitComplete,register}=context,id=(0,react.useId)();(0,react.useEffect)(()=>register(id),[]);let safeToRemove=()=>onExitComplete&&onExitComplete(id);return!isPresent&&onExitComplete?[!1,safeToRemove]:[!0]}function shallowCompare(next,prev){if(!Array.isArray(prev))return!1;let prevLength=prev.length;if(prevLength!==next.length)return!1;for(let i=0;i<prevLength;i++)if(prev[i]!==next[i])return!1;return!0}function __rest(s,e){var t={};for(var p in s)Object.prototype.hasOwnProperty.call(s,p)&&0>e.indexOf(p)&&(t[p]=s[p]);if(null!=s&&"function"==typeof Object.getOwnPropertySymbols)for(var i=0,p=Object.getOwnPropertySymbols(s);i<p.length;i++)0>e.indexOf(p[i])&&Object.prototype.propertyIsEnumerable.call(s,p[i])&&(t[p[i]]=s[p[i]]);return t}var warning=function(){},invariant=function(){};let clamp_clamp=(min,max,v)=>Math.min(Math.max(v,min),max);function calcAngularFreq(undampedFreq,dampingRatio){return undampedFreq*Math.sqrt(1-dampingRatio*dampingRatio)}let durationKeys=["duration","bounce"],physicsKeys=["stiffness","damping","mass"];function isSpringType(options,keys){return keys.some(key=>void 0!==options[key])}function spring(_a){var{from=0,to=1,restSpeed=2,restDelta}=_a,options=__rest(_a,["from","to","restSpeed","restDelta"]);let state={done:!1,value:from},{stiffness,damping,mass,velocity,duration,isResolvedFromDuration}=function(options){let springOptions=Object.assign({velocity:0,stiffness:100,damping:10,mass:1,isResolvedFromDuration:!1},options);if(!isSpringType(options,physicsKeys)&&isSpringType(options,durationKeys)){let derived=function({duration=800,bounce=.25,velocity=0,mass=1}){let envelope,derivative;warning(duration<=1e4,"Spring duration must be 10 seconds or less");let dampingRatio=1-bounce;dampingRatio=clamp_clamp(.05,1,dampingRatio),duration=clamp_clamp(.01,10,duration/1e3),dampingRatio<1?(envelope=undampedFreq=>{let exponentialDecay=undampedFreq*dampingRatio,delta=exponentialDecay*duration,b=calcAngularFreq(undampedFreq,dampingRatio);return .001-(exponentialDecay-velocity)/b*Math.exp(-delta)},derivative=undampedFreq=>{let exponentialDecay=undampedFreq*dampingRatio,delta=exponentialDecay*duration,e=Math.pow(dampingRatio,2)*Math.pow(undampedFreq,2)*duration,g=calcAngularFreq(Math.pow(undampedFreq,2),dampingRatio),factor=-envelope(undampedFreq)+.001>0?-1:1;return factor*((delta*velocity+velocity-e)*Math.exp(-delta))/g}):(envelope=undampedFreq=>{let a=Math.exp(-undampedFreq*duration),b=(undampedFreq-velocity)*duration+1;return -.001+a*b},derivative=undampedFreq=>{let a=Math.exp(-undampedFreq*duration),b=(velocity-undampedFreq)*(duration*duration);return a*b});let initialGuess=5/duration,undampedFreq=function(envelope,derivative,initialGuess){let result=initialGuess;for(let i=1;i<12;i++)result-=envelope(result)/derivative(result);return result}(envelope,derivative,initialGuess);if(duration*=1e3,isNaN(undampedFreq))return{stiffness:100,damping:10,duration};{let stiffness=Math.pow(undampedFreq,2)*mass;return{stiffness,damping:2*dampingRatio*Math.sqrt(mass*stiffness),duration}}}(options);(springOptions=Object.assign(Object.assign(Object.assign({},springOptions),derived),{velocity:0,mass:1})).isResolvedFromDuration=!0}return springOptions}(options),resolveSpring=zero,resolveVelocity=zero;function createSpring(){let initialVelocity=velocity?-(velocity/1e3):0,initialDelta=to-from,dampingRatio=damping/(2*Math.sqrt(stiffness*mass)),undampedAngularFreq=Math.sqrt(stiffness/mass)/1e3;if(void 0===restDelta&&(restDelta=Math.min(Math.abs(to-from)/100,.4)),dampingRatio<1){let angularFreq=calcAngularFreq(undampedAngularFreq,dampingRatio);resolveSpring=t=>to-Math.exp(-dampingRatio*undampedAngularFreq*t)*((initialVelocity+dampingRatio*undampedAngularFreq*initialDelta)/angularFreq*Math.sin(angularFreq*t)+initialDelta*Math.cos(angularFreq*t)),resolveVelocity=t=>{let envelope=Math.exp(-dampingRatio*undampedAngularFreq*t);return dampingRatio*undampedAngularFreq*envelope*(Math.sin(angularFreq*t)*(initialVelocity+dampingRatio*undampedAngularFreq*initialDelta)/angularFreq+initialDelta*Math.cos(angularFreq*t))-envelope*(Math.cos(angularFreq*t)*(initialVelocity+dampingRatio*undampedAngularFreq*initialDelta)-angularFreq*initialDelta*Math.sin(angularFreq*t))}}else if(1===dampingRatio)resolveSpring=t=>to-Math.exp(-undampedAngularFreq*t)*(initialDelta+(initialVelocity+undampedAngularFreq*initialDelta)*t);else{let dampedAngularFreq=undampedAngularFreq*Math.sqrt(dampingRatio*dampingRatio-1);resolveSpring=t=>{let freqForT=Math.min(dampedAngularFreq*t,300);return to-Math.exp(-dampingRatio*undampedAngularFreq*t)*((initialVelocity+dampingRatio*undampedAngularFreq*initialDelta)*Math.sinh(freqForT)+dampedAngularFreq*initialDelta*Math.cosh(freqForT))/dampedAngularFreq}}}return createSpring(),{next(t){let current=resolveSpring(t);if(isResolvedFromDuration)state.done=t>=duration;else{let currentVelocity=1e3*resolveVelocity(t),isBelowDisplacementThreshold=Math.abs(to-current)<=restDelta;state.done=Math.abs(currentVelocity)<=restSpeed&&isBelowDisplacementThreshold}return state.value=state.done?to:current,state},flipTarget(){velocity=-velocity,[from,to]=[to,from],createSpring()}}}spring.needsInterpolation=(a,b)=>"string"==typeof a||"string"==typeof b;let zero=_t=>0,progress=(from,to,value)=>{let toFromDifference=to-from;return 0===toFromDifference?1:(value-from)/toFromDifference},mix=(from,to,progress)=>-progress*from+progress*to+from,isColorString=(type,testProp)=>v=>Boolean(isString(v)&&singleColorRegex.test(v)&&v.startsWith(type)||testProp&&Object.prototype.hasOwnProperty.call(v,testProp)),splitColor=(aName,bName,cName)=>v=>{if(!isString(v))return v;let[a,b,c,alpha]=v.match(floatRegex);return{[aName]:parseFloat(a),[bName]:parseFloat(b),[cName]:parseFloat(c),alpha:void 0!==alpha?parseFloat(alpha):1}},clampRgbUnit=clamp(0,255),rgbUnit=Object.assign(Object.assign({},number),{transform:v=>Math.round(clampRgbUnit(v))}),rgba={test:isColorString("rgb","red"),parse:splitColor("red","green","blue"),transform:({red,green,blue,alpha:alpha$1=1})=>"rgba("+rgbUnit.transform(red)+", "+rgbUnit.transform(green)+", "+rgbUnit.transform(blue)+", "+sanitize(alpha.transform(alpha$1))+")"},hex={test:isColorString("#"),parse:function(v){let r="",g="",b="",a="";return v.length>5?(r=v.substr(1,2),g=v.substr(3,2),b=v.substr(5,2),a=v.substr(7,2)):(r=v.substr(1,1),g=v.substr(2,1),b=v.substr(3,1),a=v.substr(4,1),r+=r,g+=g,b+=b,a+=a),{red:parseInt(r,16),green:parseInt(g,16),blue:parseInt(b,16),alpha:a?parseInt(a,16)/255:1}},transform:rgba.transform},hsla={test:isColorString("hsl","hue"),parse:splitColor("hue","saturation","lightness"),transform:({hue,saturation,lightness,alpha:alpha$1=1})=>"hsla("+Math.round(hue)+", "+percent.transform(sanitize(saturation))+", "+percent.transform(sanitize(lightness))+", "+sanitize(alpha.transform(alpha$1))+")"};function hueToRgb(p,q,t){return(t<0&&(t+=1),t>1&&(t-=1),t<1/6)?p+(q-p)*6*t:t<.5?q:t<2/3?p+(q-p)*(2/3-t)*6:p}function hslaToRgba({hue,saturation,lightness,alpha}){hue/=360,lightness/=100;let red=0,green=0,blue=0;if(saturation/=100){let q=lightness<.5?lightness*(1+saturation):lightness+saturation-lightness*saturation,p=2*lightness-q;red=hueToRgb(p,q,hue+1/3),green=hueToRgb(p,q,hue),blue=hueToRgb(p,q,hue-1/3)}else red=green=blue=lightness;return{red:Math.round(255*red),green:Math.round(255*green),blue:Math.round(255*blue),alpha}}let mixLinearColor=(from,to,v)=>{let fromExpo=from*from;return Math.sqrt(Math.max(0,v*(to*to-fromExpo)+fromExpo))},colorTypes=[hex,rgba,hsla],getColorType=v=>colorTypes.find(type=>type.test(v)),notAnimatable=color=>`'${color}' is not an animatable color. Use the equivalent color code instead.`,mixColor=(from,to)=>{let fromColorType=getColorType(from),toColorType=getColorType(to);invariant(!!fromColorType,notAnimatable(from)),invariant(!!toColorType,notAnimatable(to));let fromColor=fromColorType.parse(from),toColor=toColorType.parse(to);fromColorType===hsla&&(fromColor=hslaToRgba(fromColor),fromColorType=rgba),toColorType===hsla&&(toColor=hslaToRgba(toColor),toColorType=rgba);let blended=Object.assign({},fromColor);return v=>{for(let key in blended)"alpha"!==key&&(blended[key]=mixLinearColor(fromColor[key],toColor[key],v));return blended.alpha=mix(fromColor.alpha,toColor.alpha,v),fromColorType.transform(blended)}},color={test:v=>rgba.test(v)||hex.test(v)||hsla.test(v),parse:v=>rgba.test(v)?rgba.parse(v):hsla.test(v)?hsla.parse(v):hex.parse(v),transform:v=>isString(v)?v:v.hasOwnProperty("red")?rgba.transform(v):hsla.transform(v)},colorToken="${c}",numberToken="${n}";function analyse(v){"number"==typeof v&&(v=`${v}`);let values=[],numColors=0,colors=v.match(colorRegex);colors&&(numColors=colors.length,v=v.replace(colorRegex,colorToken),values.push(...colors.map(color.parse)));let numbers=v.match(floatRegex);return numbers&&(v=v.replace(floatRegex,numberToken),values.push(...numbers.map(number.parse))),{values,numColors,tokenised:v}}function parse(v){return analyse(v).values}function createTransformer(v){let{values,numColors,tokenised}=analyse(v),numValues=values.length;return v=>{let output=tokenised;for(let i=0;i<numValues;i++)output=output.replace(i<numColors?colorToken:numberToken,i<numColors?color.transform(v[i]):sanitize(v[i]));return output}}let convertNumbersToZero=v=>"number"==typeof v?0:v,complex={test:function(v){var _a,_b,_c,_d;return isNaN(v)&&isString(v)&&(null!==(_b=null===(_a=v.match(floatRegex))||void 0===_a?void 0:_a.length)&&void 0!==_b?_b:0)+(null!==(_d=null===(_c=v.match(colorRegex))||void 0===_c?void 0:_c.length)&&void 0!==_d?_d:0)>0},parse,createTransformer,getAnimatableNone:function(v){let parsed=parse(v),transformer=createTransformer(v);return transformer(parsed.map(convertNumbersToZero))}},isNum=v=>"number"==typeof v;function getMixer(origin,target){return isNum(origin)?v=>mix(origin,target,v):color.test(origin)?mixColor(origin,target):mixComplex(origin,target)}let mixArray=(from,to)=>{let output=[...from],numValues=output.length,blendValue=from.map((fromThis,i)=>getMixer(fromThis,to[i]));return v=>{for(let i=0;i<numValues;i++)output[i]=blendValue[i](v);return output}},mixObject=(origin,target)=>{let output=Object.assign(Object.assign({},origin),target),blendValue={};for(let key in output)void 0!==origin[key]&&void 0!==target[key]&&(blendValue[key]=getMixer(origin[key],target[key]));return v=>{for(let key in blendValue)output[key]=blendValue[key](v);return output}};function mix_complex_analyse(value){let parsed=complex.parse(value),numValues=parsed.length,numNumbers=0,numRGB=0,numHSL=0;for(let i=0;i<numValues;i++)numNumbers||"number"==typeof parsed[i]?numNumbers++:void 0!==parsed[i].hue?numHSL++:numRGB++;return{parsed,numNumbers,numRGB,numHSL}}let mixComplex=(origin,target)=>{let template=complex.createTransformer(target),originStats=mix_complex_analyse(origin),targetStats=mix_complex_analyse(target),canInterpolate=originStats.numHSL===targetStats.numHSL&&originStats.numRGB===targetStats.numRGB&&originStats.numNumbers>=targetStats.numNumbers;return canInterpolate?pipe(mixArray(originStats.parsed,targetStats.parsed),template):(warning(!0,`Complex values '${origin}' and '${target}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`),p=>`${p>0?target:origin}`)},mixNumber=(from,to)=>p=>mix(from,to,p);function interpolate(input,output,{clamp:isClamp=!0,ease,mixer}={}){let inputLength=input.length;invariant(inputLength===output.length,"Both input and output ranges must be the same length"),invariant(!ease||!Array.isArray(ease)||ease.length===inputLength-1,"Array of easing functions must be of length `input.length - 1`, as it applies to the transitions **between** the defined values."),input[0]>input[inputLength-1]&&(input=[].concat(input),output=[].concat(output),input.reverse(),output.reverse());let mixers=function(output,ease,customMixer){var v;let mixers=[],mixerFactory=customMixer||("number"==typeof(v=output[0])?mixNumber:"string"==typeof v?color.test(v)?mixColor:mixComplex:Array.isArray(v)?mixArray:"object"==typeof v?mixObject:void 0),numMixers=output.length-1;for(let i=0;i<numMixers;i++){let mixer=mixerFactory(output[i],output[i+1]);if(ease){let easingFunction=Array.isArray(ease)?ease[i]:ease;mixer=pipe(easingFunction,mixer)}mixers.push(mixer)}return mixers}(output,ease,mixer),interpolator=2===inputLength?function([from,to],[mixer]){return v=>mixer(progress(from,to,v))}(input,mixers):function(input,mixers){let inputLength=input.length,lastInputIndex=inputLength-1;return v=>{let mixerIndex=0,foundMixerIndex=!1;if(v<=input[0]?foundMixerIndex=!0:v>=input[lastInputIndex]&&(mixerIndex=lastInputIndex-1,foundMixerIndex=!0),!foundMixerIndex){let i=1;for(;i<inputLength&&!(input[i]>v)&&i!==lastInputIndex;i++);mixerIndex=i-1}let progressInRange=progress(input[mixerIndex],input[mixerIndex+1],v);return mixers[mixerIndex](progressInRange)}}(input,mixers);return isClamp?v=>interpolator(clamp_clamp(input[0],input[inputLength-1],v)):interpolator}let reverseEasing=easing=>p=>1-easing(1-p),mirrorEasing=easing=>p=>p<=.5?easing(2*p)/2:(2-easing(2*(1-p)))/2,createBackIn=power=>p=>p*p*((power+1)*p-power),BOUNCE_FIRST_THRESHOLD=4/11,BOUNCE_SECOND_THRESHOLD=8/11,linear=p=>p,easeIn=p=>Math.pow(p,2),easeOut=reverseEasing(easeIn),easeInOut=mirrorEasing(easeIn),circIn=p=>1-Math.sin(Math.acos(p)),circOut=reverseEasing(circIn),circInOut=mirrorEasing(circOut),backIn=createBackIn(1.525),backOut=reverseEasing(backIn),backInOut=mirrorEasing(backIn),anticipate=(power=>{let backEasing=createBackIn(1.525);return p=>(p*=2)<1?.5*backEasing(p):.5*(2-Math.pow(2,-10*(p-1)))})(0),ca=4356/361,cb=35442/1805,cc=16061/1805,bounceOut=p=>{if(1===p||0===p)return p;let p2=p*p;return p<BOUNCE_FIRST_THRESHOLD?7.5625*p2:p<BOUNCE_SECOND_THRESHOLD?9.075*p2-9.9*p+3.4:p<.9?ca*p2-cb*p+cc:10.8*p*p-20.52*p+10.72},bounceIn=reverseEasing(bounceOut),bounceInOut=p=>p<.5?.5*(1-bounceOut(1-2*p)):.5*bounceOut(2*p-1)+.5;function keyframes({from=0,to=1,ease,offset,duration=300}){let state={done:!1,value:from},values=Array.isArray(to)?to:[from,to],times=(offset&&offset.length===values.length?offset:function(values){let numValues=values.length;return values.map((_value,i)=>0!==i?i/(numValues-1):0)}(values)).map(o=>o*duration);function createInterpolator(){return interpolate(times,values,{ease:Array.isArray(ease)?ease:values.map(()=>ease||easeInOut).splice(0,values.length-1)})}let interpolator=createInterpolator();return{next:t=>(state.value=interpolator(t),state.done=t>=duration,state),flipTarget(){values.reverse(),interpolator=createInterpolator()}}}let types={keyframes:keyframes,spring:spring,decay:function({velocity=0,from=0,power=.8,timeConstant=350,restDelta=.5,modifyTarget}){let state={done:!1,value:from},amplitude=power*velocity,ideal=from+amplitude,target=void 0===modifyTarget?ideal:modifyTarget(ideal);return target!==ideal&&(amplitude=target-from),{next(t){let delta=-amplitude*Math.exp(-t/timeConstant);return state.done=!(delta>restDelta||delta<-restDelta),state.value=state.done?target:target+delta,state},flipTarget(){}}}},defaultTimestep=1/60*1e3,getCurrentTime="undefined"!=typeof performance?()=>performance.now():()=>Date.now(),onNextFrame="undefined"!=typeof window?callback=>window.requestAnimationFrame(callback):callback=>setTimeout(()=>callback(getCurrentTime()),defaultTimestep),useDefaultElapsed=!0,runNextFrame=!1,isProcessing=!1,es_frame={delta:0,timestamp:0},stepsOrder=["read","update","preRender","render","postRender"],steps=stepsOrder.reduce((acc,key)=>(acc[key]=function(runNextFrame){let toRun=[],toRunNextFrame=[],numToRun=0,isProcessing=!1,flushNextFrame=!1,toKeepAlive=new WeakSet,step={schedule(callback,keepAlive=!1,immediate=!1){let addToCurrentFrame=immediate&&isProcessing,buffer=addToCurrentFrame?toRun:toRunNextFrame;return keepAlive&&toKeepAlive.add(callback),-1===buffer.indexOf(callback)&&(buffer.push(callback),addToCurrentFrame&&isProcessing&&(numToRun=toRun.length)),callback},cancel(callback){let index=toRunNextFrame.indexOf(callback);-1!==index&&toRunNextFrame.splice(index,1),toKeepAlive.delete(callback)},process(frameData){if(isProcessing){flushNextFrame=!0;return}if(isProcessing=!0,[toRun,toRunNextFrame]=[toRunNextFrame,toRun],toRunNextFrame.length=0,numToRun=toRun.length)for(let i=0;i<numToRun;i++){let callback=toRun[i];callback(frameData),toKeepAlive.has(callback)&&(step.schedule(callback),runNextFrame())}isProcessing=!1,flushNextFrame&&(flushNextFrame=!1,step.process(frameData))}};return step}(()=>runNextFrame=!0),acc),{}),sync=stepsOrder.reduce((acc,key)=>{let step=steps[key];return acc[key]=(process,keepAlive=!1,immediate=!1)=>(runNextFrame||startLoop(),step.schedule(process,keepAlive,immediate)),acc},{}),cancelSync=stepsOrder.reduce((acc,key)=>(acc[key]=steps[key].cancel,acc),{}),flushSync=stepsOrder.reduce((acc,key)=>(acc[key]=()=>steps[key].process(es_frame),acc),{}),processStep=stepId=>steps[stepId].process(es_frame),processFrame=timestamp=>{runNextFrame=!1,es_frame.delta=useDefaultElapsed?defaultTimestep:Math.max(Math.min(timestamp-es_frame.timestamp,40),1),es_frame.timestamp=timestamp,isProcessing=!0,stepsOrder.forEach(processStep),isProcessing=!1,runNextFrame&&(useDefaultElapsed=!1,onNextFrame(processFrame))},startLoop=()=>{runNextFrame=!0,useDefaultElapsed=!0,isProcessing||onNextFrame(processFrame)},getFrameData=()=>es_frame;function loopElapsed(elapsed,duration,delay=0){return elapsed-duration-delay}let framesync=update=>{let passTimestamp=({delta})=>update(delta);return{start:()=>sync.update(passTimestamp,!0),stop:()=>cancelSync.update(passTimestamp)}};function animate(_a){let driverControls,latest,interpolateFromNumber;var _c,{from,autoplay=!0,driver=framesync,elapsed=0,repeat:repeatMax=0,repeatType="loop",repeatDelay=0,onPlay,onStop,onComplete,onRepeat,onUpdate}=_a,options=__rest(_a,["from","autoplay","driver","elapsed","repeat","repeatType","repeatDelay","onPlay","onStop","onComplete","onRepeat","onUpdate"]);let{to}=options,repeatCount=0,computedDuration=options.duration,isComplete=!1,isForwardPlayback=!0,animator=function(config){if(Array.isArray(config.to))return keyframes;if(types[config.type])return types[config.type];let keys=new Set(Object.keys(config));if(keys.has("ease")||keys.has("duration")&&!keys.has("dampingRatio"));else if(keys.has("dampingRatio")||keys.has("stiffness")||keys.has("mass")||keys.has("damping")||keys.has("restSpeed")||keys.has("restDelta"))return spring;return keyframes}(options);(null===(_c=animator.needsInterpolation)||void 0===_c?void 0:_c.call(animator,from,to))&&(interpolateFromNumber=interpolate([0,100],[from,to],{clamp:!1}),from=0,to=100);let animation=animator(Object.assign(Object.assign({},options),{from,to}));return autoplay&&(null==onPlay||onPlay(),(driverControls=driver(function(delta){if(isForwardPlayback||(delta=-delta),elapsed+=delta,!isComplete){let state=animation.next(Math.max(0,elapsed));latest=state.value,interpolateFromNumber&&(latest=interpolateFromNumber(latest)),isComplete=isForwardPlayback?state.done:elapsed<=0}if(null==onUpdate||onUpdate(latest),isComplete){if(0===repeatCount&&(null!=computedDuration||(computedDuration=elapsed)),repeatCount<repeatMax){var elapsed1,duration;elapsed1=elapsed,duration=computedDuration,(isForwardPlayback?elapsed1>=duration+repeatDelay:elapsed1<=-repeatDelay)&&(repeatCount++,"reverse"===repeatType?elapsed=function(elapsed,duration,delay=0,isForwardPlayback=!0){return isForwardPlayback?loopElapsed(duration+-elapsed,duration,delay):duration-(elapsed-duration)+delay}(elapsed,computedDuration,repeatDelay,isForwardPlayback=repeatCount%2==0):(elapsed=loopElapsed(elapsed,computedDuration,repeatDelay),"mirror"===repeatType&&animation.flipTarget()),isComplete=!1,onRepeat&&onRepeat())}else driverControls.stop(),onComplete&&onComplete()}})).start()),{stop(){null==onStop||onStop(),driverControls.stop()}}}let secondsToMilliseconds=seconds=>1e3*seconds,a=(a1,a2)=>1-3*a2+3*a1,b=(a1,a2)=>3*a2-6*a1,c=a1=>3*a1,calcBezier=(t,a1,a2)=>((a(a1,a2)*t+b(a1,a2))*t+c(a1))*t,getSlope=(t,a1,a2)=>3*a(a1,a2)*t*t+2*b(a1,a2)*t+c(a1),easingLookup={linear:linear,easeIn:easeIn,easeInOut:easeInOut,easeOut:easeOut,circIn:circIn,circInOut:circInOut,circOut:circOut,backIn:backIn,backInOut:backInOut,backOut:backOut,anticipate:anticipate,bounceIn:bounceIn,bounceInOut:bounceInOut,bounceOut:bounceOut},easingDefinitionToFunction=definition=>{if(Array.isArray(definition)){invariant(4===definition.length,"Cubic bezier arrays must contain four numerical values.");let[x1,y1,x2,y2]=definition;return function(mX1,mY1,mX2,mY2){if(mX1===mY1&&mX2===mY2)return linear;let sampleValues=new Float32Array(11);for(let i=0;i<11;++i)sampleValues[i]=calcBezier(.1*i,mX1,mX2);return t=>0===t||1===t?t:calcBezier(function(aX){let intervalStart=0,currentSample=1;for(;10!==currentSample&&sampleValues[currentSample]<=aX;++currentSample)intervalStart+=.1;--currentSample;let dist=(aX-sampleValues[currentSample])/(sampleValues[currentSample+1]-sampleValues[currentSample]),guessForT=intervalStart+.1*dist,initialSlope=getSlope(guessForT,mX1,mX2);return initialSlope>=.001?function(aX,aGuessT,mX1,mX2){for(let i=0;i<8;++i){let currentSlope=getSlope(aGuessT,mX1,mX2);if(0===currentSlope)break;let currentX=calcBezier(aGuessT,mX1,mX2)-aX;aGuessT-=currentX/currentSlope}return aGuessT}(aX,guessForT,mX1,mX2):0===initialSlope?guessForT:function(aX,aA,aB,mX1,mX2){let currentX,currentT;let i=0;do(currentX=calcBezier(currentT=aA+(aB-aA)/2,mX1,mX2)-aX)>0?aB=currentT:aA=currentT;while(Math.abs(currentX)>1e-7&&++i<10);return currentT}(aX,intervalStart,intervalStart+.1,mX1,mX2)}(t),mY1,mY2)}(x1,y1,x2,y2)}return"string"==typeof definition?(invariant(void 0!==easingLookup[definition],`Invalid easing type '${definition}'`),easingLookup[definition]):definition},isEasingArray=ease=>Array.isArray(ease)&&"number"!=typeof ease[0],isAnimatable=(key,value)=>"zIndex"!==key&&!!("number"==typeof value||Array.isArray(value)||"string"==typeof value&&complex.test(value)&&!value.startsWith("url(")),underDampedSpring=()=>({type:"spring",stiffness:500,damping:25,restSpeed:10}),criticallyDampedSpring=to=>({type:"spring",stiffness:550,damping:0===to?2*Math.sqrt(550):30,restSpeed:10}),linearTween=()=>({type:"keyframes",ease:"linear",duration:.3}),default_transitions_keyframes=values=>({type:"keyframes",duration:.8,values}),defaultTransitions={x:underDampedSpring,y:underDampedSpring,z:underDampedSpring,rotate:underDampedSpring,rotateX:underDampedSpring,rotateY:underDampedSpring,rotateZ:underDampedSpring,scaleX:criticallyDampedSpring,scaleY:criticallyDampedSpring,scale:criticallyDampedSpring,opacity:linearTween,backgroundColor:linearTween,color:linearTween,default:criticallyDampedSpring},getDefaultTransition=(valueKey,to)=>({to,...(isKeyframesTarget(to)?default_transitions_keyframes:defaultTransitions[valueKey]||defaultTransitions.default)(to)}),maxDefaults=new Set(["brightness","contrast","saturate","opacity"]);function applyDefaultFilter(v){let[name,value]=v.slice(0,-1).split("(");if("drop-shadow"===name)return v;let[number]=value.match(floatRegex)||[];if(!number)return v;let unit=value.replace(number,""),defaultValue=maxDefaults.has(name)?1:0;return number!==value&&(defaultValue*=100),name+"("+defaultValue+unit+")"}let functionRegex=/([a-z-]*)\(.*?\)/g,filter=Object.assign(Object.assign({},complex),{getAnimatableNone(v){let functions=v.match(functionRegex);return functions?functions.map(applyDefaultFilter).join(" "):v}}),defaultValueTypes={...numberValueTypes,color:color,backgroundColor:color,outlineColor:color,fill:color,stroke:color,borderColor:color,borderTopColor:color,borderRightColor:color,borderBottomColor:color,borderLeftColor:color,filter:filter,WebkitFilter:filter},getDefaultValueType=key=>defaultValueTypes[key];function animatable_none_getAnimatableNone(key,value){var _a;let defaultValueType=getDefaultValueType(key);return defaultValueType!==filter&&(defaultValueType=complex),null===(_a=defaultValueType.getAnimatableNone)||void 0===_a?void 0:_a.call(defaultValueType,value)}let instantAnimationState={current:!1};function delay(callback,timeout){let start=performance.now(),checkElapsed=({timestamp})=>{let elapsed=timestamp-start;elapsed>=timeout&&(cancelSync.read(checkElapsed),callback(elapsed-timeout))};return sync.read(checkElapsed,!0),()=>cancelSync.read(checkElapsed)}let legacyRepeatWarning=!1;function isZero(value){return 0===value||"string"==typeof value&&0===parseFloat(value)&&-1===value.indexOf(" ")}function getZeroUnit(potentialUnitType){return"number"==typeof potentialUnitType?0:animatable_none_getAnimatableNone("",potentialUnitType)}function getValueTransition(transition,key){return transition[key]||transition.default||transition}function startAnimation(key,value,target,transition={}){return instantAnimationState.current&&(transition={type:!1}),value.start(onComplete=>{let controls,cancelDelay;let animation=function(key,value,target,transition,onComplete){let valueTransition=getValueTransition(transition,key)||{},origin=void 0!==valueTransition.from?valueTransition.from:value.get(),isTargetAnimatable=isAnimatable(key,target);"none"===origin&&isTargetAnimatable&&"string"==typeof target?origin=animatable_none_getAnimatableNone(key,target):isZero(origin)&&"string"==typeof target?origin=getZeroUnit(target):!Array.isArray(target)&&isZero(target)&&"string"==typeof origin&&(target=getZeroUnit(origin));let isOriginAnimatable=isAnimatable(key,origin);return warning(isOriginAnimatable===isTargetAnimatable,`You are trying to animate ${key} from "${origin}" to "${target}". ${origin} is not an animatable value - to enable this animation set ${origin} to a value animatable to ${target} via the \`style\` property.`),isOriginAnimatable&&isTargetAnimatable&&!1!==valueTransition.type?function(){var transition,options;let options1={from:origin,to:target,velocity:value.getVelocity(),onComplete,onUpdate:v=>value.set(v)};return"inertia"===valueTransition.type||"decay"===valueTransition.type?function({from=0,velocity=0,min,max,power=.8,timeConstant=750,bounceStiffness=500,bounceDamping=10,restDelta=1,modifyTarget,driver,onUpdate,onComplete,onStop}){let currentAnimation;function isOutOfBounds(v){return void 0!==min&&v<min||void 0!==max&&v>max}function boundaryNearest(v){return void 0===min?max:void 0===max?min:Math.abs(min-v)<Math.abs(max-v)?min:max}function startAnimation(options){null==currentAnimation||currentAnimation.stop(),currentAnimation=animate(Object.assign(Object.assign({},options),{driver,onUpdate(v){var _a;null==onUpdate||onUpdate(v),null===(_a=options.onUpdate)||void 0===_a||_a.call(options,v)},onComplete,onStop}))}function startSpring(options){startAnimation(Object.assign({type:"spring",stiffness:bounceStiffness,damping:bounceDamping,restDelta},options))}if(isOutOfBounds(from))startSpring({from,velocity,to:boundaryNearest(from)});else{let prev,current,target=power*velocity+from;void 0!==modifyTarget&&(target=modifyTarget(target));let boundary=boundaryNearest(target),heading=boundary===min?-1:1,checkBoundary=v=>{var frameDuration;prev=current,current=v,velocity=(frameDuration=getFrameData().delta)?(v-prev)*(1e3/frameDuration):0,(1===heading&&v>boundary||-1===heading&&v<boundary)&&startSpring({from:v,to:boundary,velocity})};startAnimation({type:"decay",from,velocity,timeConstant,power,restDelta,modifyTarget,onUpdate:isOutOfBounds(target)?checkBoundary:void 0})}return{stop:()=>null==currentAnimation?void 0:currentAnimation.stop()}}({...options1,...valueTransition}):animate({...(transition=valueTransition,Array.isArray(options1.to)&&void 0===transition.duration&&(transition.duration=.8),Array.isArray((options=options1).to)&&null===options.to[0]&&(options.to=[...options.to],options.to[0]=options.from),!function({when,delay:_delay,delayChildren,staggerChildren,staggerDirection,repeat,repeatType,repeatDelay,from,...transition}){return!!Object.keys(transition).length}(transition)&&(transition={...transition,...getDefaultTransition(key,options1.to)}),{...options1,...function({ease,times,yoyo,flip,loop,...transition}){let options={...transition};return times&&(options.offset=times),transition.duration&&(options.duration=secondsToMilliseconds(transition.duration)),transition.repeatDelay&&(options.repeatDelay=secondsToMilliseconds(transition.repeatDelay)),ease&&(options.ease=isEasingArray(ease)?ease.map(easingDefinitionToFunction):easingDefinitionToFunction(ease)),"tween"===transition.type&&(options.type="keyframes"),(yoyo||loop||flip)&&(warning(!legacyRepeatWarning,"yoyo, loop and flip have been removed from the API. Replace with repeat and repeatType options."),legacyRepeatWarning=!0,yoyo?options.repeatType="reverse":loop?options.repeatType="loop":flip&&(options.repeatType="mirror"),options.repeat=loop||yoyo||flip||transition.repeat),"spring"!==transition.type&&(options.type="keyframes"),options}(transition)}),onUpdate(v){options1.onUpdate(v),valueTransition.onUpdate&&valueTransition.onUpdate(v)},onComplete(){options1.onComplete(),valueTransition.onComplete&&valueTransition.onComplete()}})}:function(){let finalTarget=resolveFinalValueInKeyframes(target);return value.set(finalTarget),onComplete(),valueTransition.onUpdate&&valueTransition.onUpdate(finalTarget),valueTransition.onComplete&&valueTransition.onComplete(),{stop(){}}}}(key,value,target,transition,onComplete),delayBy=function(transition,key){var _a,_b;let valueTransition=getValueTransition(transition,key)||{};return null!==(_b=null!==(_a=valueTransition.delay)&&void 0!==_a?_a:transition.delay)&&void 0!==_b?_b:0}(transition,key),start=()=>controls=animation();return delayBy?cancelDelay=delay(start,secondsToMilliseconds(delayBy)):start(),()=>{cancelDelay&&cancelDelay(),controls&&controls.stop()}})}let isNumericalString=v=>/^\-?\d*\.?\d+$/.test(v),isZeroValueString=v=>/^0[^.\s]+$/.test(v);function addUniqueItem(arr,item){-1===arr.indexOf(item)&&arr.push(item)}function removeItem(arr,item){let index=arr.indexOf(item);index>-1&&arr.splice(index,1)}class SubscriptionManager{constructor(){this.subscriptions=[]}add(handler){return addUniqueItem(this.subscriptions,handler),()=>removeItem(this.subscriptions,handler)}notify(a,b,c){let numSubscriptions=this.subscriptions.length;if(numSubscriptions){if(1===numSubscriptions)this.subscriptions[0](a,b,c);else for(let i=0;i<numSubscriptions;i++){let handler=this.subscriptions[i];handler&&handler(a,b,c)}}}getSize(){return this.subscriptions.length}clear(){this.subscriptions.length=0}}let isFloat=value=>!isNaN(parseFloat(value));class MotionValue{constructor(init){this.version="7.6.6",this.timeDelta=0,this.lastUpdated=0,this.updateSubscribers=new SubscriptionManager,this.velocityUpdateSubscribers=new SubscriptionManager,this.renderSubscribers=new SubscriptionManager,this.canTrackVelocity=!1,this.updateAndNotify=(v,render=!0)=>{this.prev=this.current,this.current=v;let{delta,timestamp}=getFrameData();this.lastUpdated!==timestamp&&(this.timeDelta=delta,this.lastUpdated=timestamp,sync.postRender(this.scheduleVelocityCheck)),this.prev!==this.current&&this.updateSubscribers.notify(this.current),this.velocityUpdateSubscribers.getSize()&&this.velocityUpdateSubscribers.notify(this.getVelocity()),render&&this.renderSubscribers.notify(this.current)},this.scheduleVelocityCheck=()=>sync.postRender(this.velocityCheck),this.velocityCheck=({timestamp})=>{timestamp!==this.lastUpdated&&(this.prev=this.current,this.velocityUpdateSubscribers.notify(this.getVelocity()))},this.hasAnimated=!1,this.prev=this.current=init,this.canTrackVelocity=isFloat(this.current)}onChange(subscription){return this.updateSubscribers.add(subscription)}clearListeners(){this.updateSubscribers.clear()}onRenderRequest(subscription){return subscription(this.get()),this.renderSubscribers.add(subscription)}attach(passiveEffect){this.passiveEffect=passiveEffect}set(v,render=!0){render&&this.passiveEffect?this.passiveEffect(v,this.updateAndNotify):this.updateAndNotify(v,render)}get(){return this.current}getPrevious(){return this.prev}getVelocity(){var velocity,frameDuration;return this.canTrackVelocity?(velocity=parseFloat(this.current)-parseFloat(this.prev),(frameDuration=this.timeDelta)?velocity*(1e3/frameDuration):0):0}start(animation){return this.stop(),new Promise(resolve=>{this.hasAnimated=!0,this.stopAnimation=animation(resolve)}).then(()=>this.clearAnimation())}stop(){this.stopAnimation&&this.stopAnimation(),this.clearAnimation()}isAnimating(){return!!this.stopAnimation}clearAnimation(){this.stopAnimation=null}destroy(){this.updateSubscribers.clear(),this.renderSubscribers.clear(),this.stop()}}function motionValue(init){return new MotionValue(init)}let testValueType=v=>type=>type.test(v),dimensionValueTypes=[number,px,percent,degrees,vw,vh,{test:v=>"auto"===v,parse:v=>v}],findDimensionValueType=v=>dimensionValueTypes.find(testValueType(v)),valueTypes=[...dimensionValueTypes,color,complex],findValueType=v=>valueTypes.find(testValueType(v));function resolveVariant(visualElement,definition,custom){let props=visualElement.getProps();return resolveVariantFromProps(props,definition,void 0!==custom?custom:props.custom,function(visualElement){let current={};return visualElement.values.forEach((value,key)=>current[key]=value.get()),current}(visualElement),function(visualElement){let velocity={};return visualElement.values.forEach((value,key)=>velocity[key]=value.getVelocity()),velocity}(visualElement))}function isWillChangeMotionValue(value){return Boolean(isMotionValue(value)&&value.add)}function animateVariant(visualElement,variant,options={}){var _a;let resolved=resolveVariant(visualElement,variant,options.custom),{transition=visualElement.getDefaultTransition()||{}}=resolved||{};options.transitionOverride&&(transition=options.transitionOverride);let getAnimation=resolved?()=>animateTarget(visualElement,resolved,options):()=>Promise.resolve(),getChildAnimations=(null===(_a=visualElement.variantChildren)||void 0===_a?void 0:_a.size)?(forwardDelay=0)=>{let{delayChildren=0,staggerChildren,staggerDirection}=transition;return function(visualElement,variant,delayChildren=0,staggerChildren=0,staggerDirection=1,options){let animations=[],maxStaggerDuration=(visualElement.variantChildren.size-1)*staggerChildren,generateStaggerDuration=1===staggerDirection?(i=0)=>i*staggerChildren:(i=0)=>maxStaggerDuration-i*staggerChildren;return Array.from(visualElement.variantChildren).sort(sortByTreeOrder).forEach((child,i)=>{animations.push(animateVariant(child,variant,{...options,delay:delayChildren+generateStaggerDuration(i)}).then(()=>child.notify("AnimationComplete",variant)))}),Promise.all(animations)}(visualElement,variant,delayChildren+forwardDelay,staggerChildren,staggerDirection,options)}:()=>Promise.resolve(),{when}=transition;if(!when)return Promise.all([getAnimation(),getChildAnimations(options.delay)]);{let[first,last]="beforeChildren"===when?[getAnimation,getChildAnimations]:[getChildAnimations,getAnimation];return first().then(last)}}function animateTarget(visualElement,definition,{delay=0,transitionOverride,type}={}){var _a;let{transition=visualElement.getDefaultTransition(),transitionEnd,...target}=visualElement.makeTargetAnimatable(definition),willChange=visualElement.getValue("willChange");transitionOverride&&(transition=transitionOverride);let animations=[],animationTypeState=type&&(null===(_a=visualElement.animationState)||void 0===_a?void 0:_a.getState()[type]);for(let key in target){let value=visualElement.getValue(key),valueTarget=target[key];if(!value||void 0===valueTarget||animationTypeState&&function({protectedKeys,needsAnimating},key){let shouldBlock=protectedKeys.hasOwnProperty(key)&&!0!==needsAnimating[key];return needsAnimating[key]=!1,shouldBlock}(animationTypeState,key))continue;let valueTransition={delay,...transition};visualElement.shouldReduceMotion&&transformProps.has(key)&&(valueTransition={...valueTransition,type:!1,delay:0});let animation=startAnimation(key,value,valueTarget,valueTransition);isWillChangeMotionValue(willChange)&&(willChange.add(key),animation=animation.then(()=>willChange.remove(key))),animations.push(animation)}return Promise.all(animations).then(()=>{transitionEnd&&function(visualElement,definition){let resolved=resolveVariant(visualElement,definition),{transitionEnd={},transition={},...target}=resolved?visualElement.makeTargetAnimatable(resolved,!1):{};for(let key in target={...target,...transitionEnd}){var key1;let value=resolveFinalValueInKeyframes(target[key]);key1=key,visualElement.hasValue(key1)?visualElement.getValue(key1).set(value):visualElement.addValue(key1,motionValue(value))}}(visualElement,transitionEnd)})}function sortByTreeOrder(a,b){return a.sortNodePosition(b)}let variantPriorityOrder=[AnimationType1.Animate,AnimationType1.InView,AnimationType1.Focus,AnimationType1.Hover,AnimationType1.Tap,AnimationType1.Drag,AnimationType1.Exit],reversePriorityOrder=[...variantPriorityOrder].reverse(),numAnimationTypes=variantPriorityOrder.length;function createTypeState(isActive=!1){return{isActive,protectedKeys:{},needsAnimating:{},prevResolvedValues:{}}}let animations={animation:makeRenderlessComponent(({visualElement,animate})=>{visualElement.animationState||(visualElement.animationState=function(visualElement){let animate=animations=>Promise.all(animations.map(({animation,options})=>(function(visualElement,definition,options={}){let animation;if(visualElement.notify("AnimationStart",definition),Array.isArray(definition)){let animations=definition.map(variant=>animateVariant(visualElement,variant,options));animation=Promise.all(animations)}else if("string"==typeof definition)animation=animateVariant(visualElement,definition,options);else{let resolvedDefinition="function"==typeof definition?resolveVariant(visualElement,definition,options.custom):definition;animation=animateTarget(visualElement,resolvedDefinition,options)}return animation.then(()=>visualElement.notify("AnimationComplete",definition))})(visualElement,animation,options))),state={[AnimationType1.Animate]:createTypeState(!0),[AnimationType1.InView]:createTypeState(),[AnimationType1.Hover]:createTypeState(),[AnimationType1.Tap]:createTypeState(),[AnimationType1.Drag]:createTypeState(),[AnimationType1.Focus]:createTypeState(),[AnimationType1.Exit]:createTypeState()},isInitialRender=!0,buildResolvedTypeValues=(acc,definition)=>{let resolved=resolveVariant(visualElement,definition);if(resolved){let{transition,transitionEnd,...target}=resolved;acc={...acc,...target,...transitionEnd}}return acc};function animateChanges(options,changedActiveType){var _a,prev;let props=visualElement.getProps(),context=visualElement.getVariantContext(!0)||{},animations=[],removedKeys=new Set,encounteredKeys={},removedVariantIndex=1/0;for(let i=0;i<numAnimationTypes;i++){let type=reversePriorityOrder[i],typeState=state[type],prop=null!==(_a=props[type])&&void 0!==_a?_a:context[type],propIsVariant=isVariantLabel(prop),activeDelta=type===changedActiveType?typeState.isActive:null;!1===activeDelta&&(removedVariantIndex=i);let isInherited=prop===context[type]&&prop!==props[type]&&propIsVariant;if(isInherited&&isInitialRender&&visualElement.manuallyAnimateOnMount&&(isInherited=!1),typeState.protectedKeys={...encounteredKeys},!typeState.isActive&&null===activeDelta||!prop&&!typeState.prevProp||isAnimationControls(prop)||"boolean"==typeof prop)continue;let variantDidChange=(prev=typeState.prevProp,"string"==typeof prop?prop!==prev:!!Array.isArray(prop)&&!shallowCompare(prop,prev)),shouldAnimateType=variantDidChange||type===changedActiveType&&typeState.isActive&&!isInherited&&propIsVariant||i>removedVariantIndex&&propIsVariant,definitionList=Array.isArray(prop)?prop:[prop],resolvedValues=definitionList.reduce(buildResolvedTypeValues,{});!1===activeDelta&&(resolvedValues={});let{prevResolvedValues={}}=typeState,allKeys={...prevResolvedValues,...resolvedValues},markToAnimate=key=>{shouldAnimateType=!0,removedKeys.delete(key),typeState.needsAnimating[key]=!0};for(let key in allKeys){let next=resolvedValues[key],prev1=prevResolvedValues[key];encounteredKeys.hasOwnProperty(key)||(next!==prev1?isKeyframesTarget(next)&&isKeyframesTarget(prev1)?!shallowCompare(next,prev1)||variantDidChange?markToAnimate(key):typeState.protectedKeys[key]=!0:void 0!==next?markToAnimate(key):removedKeys.add(key):void 0!==next&&removedKeys.has(key)?markToAnimate(key):typeState.protectedKeys[key]=!0)}typeState.prevProp=prop,typeState.prevResolvedValues=resolvedValues,typeState.isActive&&(encounteredKeys={...encounteredKeys,...resolvedValues}),isInitialRender&&visualElement.blockInitialAnimation&&(shouldAnimateType=!1),shouldAnimateType&&!isInherited&&animations.push(...definitionList.map(animation=>({animation:animation,options:{type,...options}})))}if(removedKeys.size){let fallbackAnimation={};removedKeys.forEach(key=>{let fallbackTarget=visualElement.getBaseTarget(key);void 0!==fallbackTarget&&(fallbackAnimation[key]=fallbackTarget)}),animations.push({animation:fallbackAnimation})}let shouldAnimate=Boolean(animations.length);return isInitialRender&&!1===props.initial&&!visualElement.manuallyAnimateOnMount&&(shouldAnimate=!1),isInitialRender=!1,shouldAnimate?animate(animations):Promise.resolve()}return{animateChanges,setActive:function(type,isActive,options){var _a;if(state[type].isActive===isActive)return Promise.resolve();null===(_a=visualElement.variantChildren)||void 0===_a||_a.forEach(child=>{var _a;return null===(_a=child.animationState)||void 0===_a?void 0:_a.setActive(type,isActive)}),state[type].isActive=isActive;let animations=animateChanges(options,type);for(let key in state)state[key].protectedKeys={};return animations},setAnimateFunction:function(makeAnimator){animate=makeAnimator(visualElement)},getState:()=>state}}(visualElement)),isAnimationControls(animate)&&(0,react.useEffect)(()=>animate.subscribe(visualElement),[animate])}),exit:makeRenderlessComponent(props=>{let{custom,visualElement}=props,[isPresent,safeToRemove]=usePresence(),presenceContext=(0,react.useContext)(PresenceContext_PresenceContext);(0,react.useEffect)(()=>{visualElement.isPresent=isPresent;let animation=visualElement.animationState&&visualElement.animationState.setActive(AnimationType1.Exit,!isPresent,{custom:presenceContext&&presenceContext.custom||custom});animation&&!isPresent&&animation.then(safeToRemove)},[isPresent])})},isPoint=point=>point.hasOwnProperty("x")&&point.hasOwnProperty("y"),isPoint3D=point=>isPoint(point)&&point.hasOwnProperty("z"),distance1D=(a,b)=>Math.abs(a-b);function distance(a,b){if(isNum(a)&&isNum(b))return distance1D(a,b);if(isPoint(a)&&isPoint(b)){let xDelta=distance1D(a.x,b.x),yDelta=distance1D(a.y,b.y),zDelta=isPoint3D(a)&&isPoint3D(b)?distance1D(a.z,b.z):0;return Math.sqrt(Math.pow(xDelta,2)+Math.pow(yDelta,2)+Math.pow(zDelta,2))}}class PanSession{constructor(event,handlers,{transformPagePoint}={}){if(this.startEvent=null,this.lastMoveEvent=null,this.lastMoveEventInfo=null,this.handlers={},this.updatePoint=()=>{if(!(this.lastMoveEvent&&this.lastMoveEventInfo))return;let info=getPanInfo(this.lastMoveEventInfo,this.history),isPanStarted=null!==this.startEvent,isDistancePastThreshold=distance(info.offset,{x:0,y:0})>=3;if(!isPanStarted&&!isDistancePastThreshold)return;let{point}=info,{timestamp}=getFrameData();this.history.push({...point,timestamp});let{onStart,onMove}=this.handlers;isPanStarted||(onStart&&onStart(this.lastMoveEvent,info),this.startEvent=this.lastMoveEvent),onMove&&onMove(this.lastMoveEvent,info)},this.handlePointerMove=(event,info)=>{if(this.lastMoveEvent=event,this.lastMoveEventInfo=transformPoint(info,this.transformPagePoint),isMouseEvent(event)&&0===event.buttons){this.handlePointerUp(event,info);return}sync.update(this.updatePoint,!0)},this.handlePointerUp=(event,info)=>{this.end();let{onEnd,onSessionEnd}=this.handlers,panInfo=getPanInfo(transformPoint(info,this.transformPagePoint),this.history);this.startEvent&&onEnd&&onEnd(event,panInfo),onSessionEnd&&onSessionEnd(event,panInfo)},isTouchEvent(event)&&event.touches.length>1)return;this.handlers=handlers,this.transformPagePoint=transformPagePoint;let info=extractEventInfo(event),initialInfo=transformPoint(info,this.transformPagePoint),{point}=initialInfo,{timestamp}=getFrameData();this.history=[{...point,timestamp}];let{onSessionStart}=handlers;onSessionStart&&onSessionStart(event,getPanInfo(initialInfo,this.history)),this.removeListeners=pipe(addPointerEvent(window,"pointermove",this.handlePointerMove),addPointerEvent(window,"pointerup",this.handlePointerUp),addPointerEvent(window,"pointercancel",this.handlePointerUp))}updateHandlers(handlers){this.handlers=handlers}end(){this.removeListeners&&this.removeListeners(),cancelSync.update(this.updatePoint)}}function transformPoint(info,transformPagePoint){return transformPagePoint?{point:transformPagePoint(info.point)}:info}function subtractPoint(a,b){return{x:a.x-b.x,y:a.y-b.y}}function getPanInfo({point},history){return{point,delta:subtractPoint(point,lastDevicePoint(history)),offset:subtractPoint(point,history[0]),velocity:function(history,timeDelta){if(history.length<2)return{x:0,y:0};let i=history.length-1,timestampedPoint=null,lastPoint=lastDevicePoint(history);for(;i>=0&&(timestampedPoint=history[i],!(lastPoint.timestamp-timestampedPoint.timestamp>secondsToMilliseconds(.1)));)i--;if(!timestampedPoint)return{x:0,y:0};let time=(lastPoint.timestamp-timestampedPoint.timestamp)/1e3;if(0===time)return{x:0,y:0};let currentVelocity={x:(lastPoint.x-timestampedPoint.x)/time,y:(lastPoint.y-timestampedPoint.y)/time};return currentVelocity.x===1/0&&(currentVelocity.x=0),currentVelocity.y===1/0&&(currentVelocity.y=0),currentVelocity}(history,0)}}function lastDevicePoint(history){return history[history.length-1]}function calcLength(axis){return axis.max-axis.min}function isNear(value,target=0,maxDistance=.01){return distance(value,target)<maxDistance}function calcAxisDelta(delta,source,target,origin=.5){delta.origin=origin,delta.originPoint=mix(source.min,source.max,delta.origin),delta.scale=calcLength(target)/calcLength(source),(isNear(delta.scale,1,1e-4)||isNaN(delta.scale))&&(delta.scale=1),delta.translate=mix(target.min,target.max,delta.origin)-delta.originPoint,(isNear(delta.translate)||isNaN(delta.translate))&&(delta.translate=0)}function calcBoxDelta(delta,source,target,origin){calcAxisDelta(delta.x,source.x,target.x,null==origin?void 0:origin.originX),calcAxisDelta(delta.y,source.y,target.y,null==origin?void 0:origin.originY)}function calcRelativeAxis(target,relative,parent){target.min=parent.min+relative.min,target.max=target.min+calcLength(relative)}function calcRelativeAxisPosition(target,layout,parent){target.min=layout.min-parent.min,target.max=target.min+calcLength(layout)}function calcRelativePosition(target,layout,parent){calcRelativeAxisPosition(target.x,layout.x,parent.x),calcRelativeAxisPosition(target.y,layout.y,parent.y)}function calcRelativeAxisConstraints(axis,min,max){return{min:void 0!==min?axis.min+min:void 0,max:void 0!==max?axis.max+max-(axis.max-axis.min):void 0}}function calcViewportAxisConstraints(layoutAxis,constraintsAxis){let min=constraintsAxis.min-layoutAxis.min,max=constraintsAxis.max-layoutAxis.max;return constraintsAxis.max-constraintsAxis.min<layoutAxis.max-layoutAxis.min&&([min,max]=[max,min]),{min,max}}function resolveAxisElastic(dragElastic,minLabel,maxLabel){return{min:resolvePointElastic(dragElastic,minLabel),max:resolvePointElastic(dragElastic,maxLabel)}}function resolvePointElastic(dragElastic,label){var _a;return"number"==typeof dragElastic?dragElastic:null!==(_a=dragElastic[label])&&void 0!==_a?_a:0}let createAxisDelta=()=>({translate:0,scale:1,origin:0,originPoint:0}),createDelta=()=>({x:createAxisDelta(),y:createAxisDelta()}),createAxis=()=>({min:0,max:0}),createBox=()=>({x:createAxis(),y:createAxis()});function eachAxis(callback){return[callback("x"),callback("y")]}function convertBoundingBoxToBox({top,left,right,bottom}){return{x:{min:left,max:right},y:{min:top,max:bottom}}}function isIdentityScale(scale){return void 0===scale||1===scale}function hasScale({scale,scaleX,scaleY}){return!isIdentityScale(scale)||!isIdentityScale(scaleX)||!isIdentityScale(scaleY)}function hasTransform(values){return hasScale(values)||has2DTranslate(values)||values.z||values.rotate||values.rotateX||values.rotateY}function has2DTranslate(values){var value,value1;return(value=values.x)&&"0%"!==value||(value1=values.y)&&"0%"!==value1}function applyPointDelta(point,translate,scale,originPoint,boxScale){return void 0!==boxScale&&(point=originPoint+boxScale*(point-originPoint)),originPoint+scale*(point-originPoint)+translate}function applyAxisDelta(axis,translate=0,scale=1,originPoint,boxScale){axis.min=applyPointDelta(axis.min,translate,scale,originPoint,boxScale),axis.max=applyPointDelta(axis.max,translate,scale,originPoint,boxScale)}function applyBoxDelta(box,{x,y}){applyAxisDelta(box.x,x.translate,x.scale,x.originPoint),applyAxisDelta(box.y,y.translate,y.scale,y.originPoint)}function translateAxis(axis,distance){axis.min=axis.min+distance,axis.max=axis.max+distance}function transformAxis(axis,transforms,[key,scaleKey,originKey]){let axisOrigin=void 0!==transforms[originKey]?transforms[originKey]:.5,originPoint=mix(axis.min,axis.max,axisOrigin);applyAxisDelta(axis,transforms[key],transforms[scaleKey],originPoint,transforms.scale)}let xKeys=["x","scaleX","originX"],yKeys=["y","scaleY","originY"];function transformBox(box,transform){transformAxis(box.x,transform,xKeys),transformAxis(box.y,transform,yKeys)}function measureViewportBox(instance,transformPoint){return convertBoundingBoxToBox(function(point,transformPoint){if(!transformPoint)return point;let topLeft=transformPoint({x:point.left,y:point.top}),bottomRight=transformPoint({x:point.right,y:point.bottom});return{top:topLeft.y,left:topLeft.x,bottom:bottomRight.y,right:bottomRight.x}}(instance.getBoundingClientRect(),transformPoint))}let elementDragControls=new WeakMap;class VisualElementDragControls{constructor(visualElement){this.openGlobalLock=null,this.isDragging=!1,this.currentDirection=null,this.originPoint={x:0,y:0},this.constraints=!1,this.hasMutatedConstraints=!1,this.elastic=createBox(),this.visualElement=visualElement}start(originEvent,{snapToCursor=!1}={}){if(!1===this.visualElement.isPresent)return;let onSessionStart=event=>{this.stopAnimation(),snapToCursor&&this.snapToCursor(extractEventInfo(event,"page").point)},onStart=(event,info)=>{var _a;let{drag,dragPropagation,onDragStart}=this.getProps();(!drag||dragPropagation||(this.openGlobalLock&&this.openGlobalLock(),this.openGlobalLock=getGlobalLock(drag),this.openGlobalLock))&&(this.isDragging=!0,this.currentDirection=null,this.resolveConstraints(),this.visualElement.projection&&(this.visualElement.projection.isAnimationBlocked=!0,this.visualElement.projection.target=void 0),eachAxis(axis=>{var _a,_b;let current=this.getAxisMotionValue(axis).get()||0;if(percent.test(current)){let measuredAxis=null===(_b=null===(_a=this.visualElement.projection)||void 0===_a?void 0:_a.layout)||void 0===_b?void 0:_b.layoutBox[axis];if(measuredAxis){let length=calcLength(measuredAxis);current=length*(parseFloat(current)/100)}}this.originPoint[axis]=current}),null==onDragStart||onDragStart(event,info),null===(_a=this.visualElement.animationState)||void 0===_a||_a.setActive(AnimationType1.Drag,!0))},onMove=(event,info)=>{let{dragPropagation,dragDirectionLock,onDirectionLock,onDrag}=this.getProps();if(!dragPropagation&&!this.openGlobalLock)return;let{offset}=info;if(dragDirectionLock&&null===this.currentDirection){this.currentDirection=function(offset,lockThreshold=10){let direction=null;return Math.abs(offset.y)>lockThreshold?direction="y":Math.abs(offset.x)>lockThreshold&&(direction="x"),direction}(offset),null!==this.currentDirection&&(null==onDirectionLock||onDirectionLock(this.currentDirection));return}this.updateAxis("x",info.point,offset),this.updateAxis("y",info.point,offset),this.visualElement.render(),null==onDrag||onDrag(event,info)},onSessionEnd=(event,info)=>this.stop(event,info);this.panSession=new PanSession(originEvent,{onSessionStart,onStart,onMove,onSessionEnd},{transformPagePoint:this.visualElement.getTransformPagePoint()})}stop(event,info){let isDragging=this.isDragging;if(this.cancel(),!isDragging)return;let{velocity}=info;this.startAnimation(velocity);let{onDragEnd}=this.getProps();null==onDragEnd||onDragEnd(event,info)}cancel(){var _a,_b;this.isDragging=!1,this.visualElement.projection&&(this.visualElement.projection.isAnimationBlocked=!1),null===(_a=this.panSession)||void 0===_a||_a.end(),this.panSession=void 0;let{dragPropagation}=this.getProps();!dragPropagation&&this.openGlobalLock&&(this.openGlobalLock(),this.openGlobalLock=null),null===(_b=this.visualElement.animationState)||void 0===_b||_b.setActive(AnimationType1.Drag,!1)}updateAxis(axis,_point,offset){let{drag}=this.getProps();if(!offset||!shouldDrag(axis,drag,this.currentDirection))return;let axisValue=this.getAxisMotionValue(axis),next=this.originPoint[axis]+offset[axis];this.constraints&&this.constraints[axis]&&(next=function(point,{min,max},elastic){return void 0!==min&&point<min?point=elastic?mix(min,point,elastic.min):Math.max(point,min):void 0!==max&&point>max&&(point=elastic?mix(max,point,elastic.max):Math.min(point,max)),point}(next,this.constraints[axis],this.elastic[axis])),axisValue.set(next)}resolveConstraints(){let{dragConstraints,dragElastic}=this.getProps(),{layout}=this.visualElement.projection||{},prevConstraints=this.constraints;dragConstraints&&isRefObject(dragConstraints)?this.constraints||(this.constraints=this.resolveRefConstraints()):dragConstraints&&layout?this.constraints=function(layoutBox,{top,left,bottom,right}){return{x:calcRelativeAxisConstraints(layoutBox.x,left,right),y:calcRelativeAxisConstraints(layoutBox.y,top,bottom)}}(layout.layoutBox,dragConstraints):this.constraints=!1,this.elastic=function(dragElastic=.35){return!1===dragElastic?dragElastic=0:!0===dragElastic&&(dragElastic=.35),{x:resolveAxisElastic(dragElastic,"left","right"),y:resolveAxisElastic(dragElastic,"top","bottom")}}(dragElastic),prevConstraints!==this.constraints&&layout&&this.constraints&&!this.hasMutatedConstraints&&eachAxis(axis=>{this.getAxisMotionValue(axis)&&(this.constraints[axis]=function(layout,constraints){let relativeConstraints={};return void 0!==constraints.min&&(relativeConstraints.min=constraints.min-layout.min),void 0!==constraints.max&&(relativeConstraints.max=constraints.max-layout.min),relativeConstraints}(layout.layoutBox[axis],this.constraints[axis]))})}resolveRefConstraints(){var layoutBox;let{dragConstraints:constraints,onMeasureDragConstraints}=this.getProps();if(!constraints||!isRefObject(constraints))return!1;let constraintsElement=constraints.current;invariant(null!==constraintsElement,"If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.");let{projection}=this.visualElement;if(!projection||!projection.layout)return!1;let constraintsBox=function(element,rootProjectionNode,transformPagePoint){let viewportBox=measureViewportBox(element,transformPagePoint),{scroll}=rootProjectionNode;return scroll&&(translateAxis(viewportBox.x,scroll.x),translateAxis(viewportBox.y,scroll.y)),viewportBox}(constraintsElement,projection.root,this.visualElement.getTransformPagePoint()),measuredConstraints={x:calcViewportAxisConstraints((layoutBox=projection.layout.layoutBox).x,constraintsBox.x),y:calcViewportAxisConstraints(layoutBox.y,constraintsBox.y)};if(onMeasureDragConstraints){let userConstraints=onMeasureDragConstraints(function({x,y}){return{top:y.min,right:x.max,bottom:y.max,left:x.min}}(measuredConstraints));this.hasMutatedConstraints=!!userConstraints,userConstraints&&(measuredConstraints=convertBoundingBoxToBox(userConstraints))}return measuredConstraints}startAnimation(velocity){let{drag,dragMomentum,dragElastic,dragTransition,dragSnapToOrigin,onDragTransitionEnd}=this.getProps(),constraints=this.constraints||{},momentumAnimations=eachAxis(axis=>{var _a;if(!shouldDrag(axis,drag,this.currentDirection))return;let transition=null!==(_a=null==constraints?void 0:constraints[axis])&&void 0!==_a?_a:{};dragSnapToOrigin&&(transition={min:0,max:0});let inertia={type:"inertia",velocity:dragMomentum?velocity[axis]:0,bounceStiffness:dragElastic?200:1e6,bounceDamping:dragElastic?40:1e7,timeConstant:750,restDelta:1,restSpeed:10,...dragTransition,...transition};return this.startAxisValueAnimation(axis,inertia)});return Promise.all(momentumAnimations).then(onDragTransitionEnd)}startAxisValueAnimation(axis,transition){let axisValue=this.getAxisMotionValue(axis);return startAnimation(axis,axisValue,0,transition)}stopAnimation(){eachAxis(axis=>this.getAxisMotionValue(axis).stop())}getAxisMotionValue(axis){var _a,_b;let dragKey="_drag"+axis.toUpperCase(),externalMotionValue=this.visualElement.getProps()[dragKey];return externalMotionValue||this.visualElement.getValue(axis,null!==(_b=null===(_a=this.visualElement.getProps().initial)||void 0===_a?void 0:_a[axis])&&void 0!==_b?_b:0)}snapToCursor(point){eachAxis(axis=>{let{drag}=this.getProps();if(!shouldDrag(axis,drag,this.currentDirection))return;let{projection}=this.visualElement,axisValue=this.getAxisMotionValue(axis);if(projection&&projection.layout){let{min,max}=projection.layout.layoutBox[axis];axisValue.set(point[axis]-mix(min,max,.5))}})}scalePositionWithinConstraints(){var _a;if(!this.visualElement.current)return;let{drag,dragConstraints}=this.getProps(),{projection}=this.visualElement;if(!isRefObject(dragConstraints)||!projection||!this.constraints)return;this.stopAnimation();let boxProgress={x:0,y:0};eachAxis(axis=>{let axisValue=this.getAxisMotionValue(axis);if(axisValue){let latest=axisValue.get();boxProgress[axis]=function(source,target){let origin=.5,sourceLength=calcLength(source),targetLength=calcLength(target);return targetLength>sourceLength?origin=progress(target.min,target.max-sourceLength,source.min):sourceLength>targetLength&&(origin=progress(source.min,source.max-targetLength,target.min)),clamp_clamp(0,1,origin)}({min:latest,max:latest},this.constraints[axis])}});let{transformTemplate}=this.visualElement.getProps();this.visualElement.current.style.transform=transformTemplate?transformTemplate({},""):"none",null===(_a=projection.root)||void 0===_a||_a.updateScroll(),projection.updateLayout(),this.resolveConstraints(),eachAxis(axis=>{if(!shouldDrag(axis,drag,null))return;let axisValue=this.getAxisMotionValue(axis),{min,max}=this.constraints[axis];axisValue.set(mix(min,max,boxProgress[axis]))})}addListeners(){var _a;if(!this.visualElement.current)return;elementDragControls.set(this.visualElement,this);let element=this.visualElement.current,stopPointerListener=addPointerEvent(element,"pointerdown",event=>{let{drag,dragListener=!0}=this.getProps();drag&&dragListener&&this.start(event)}),measureDragConstraints=()=>{let{dragConstraints}=this.getProps();isRefObject(dragConstraints)&&(this.constraints=this.resolveRefConstraints())},{projection}=this.visualElement,stopMeasureLayoutListener=projection.addEventListener("measure",measureDragConstraints);projection&&!projection.layout&&(null===(_a=projection.root)||void 0===_a||_a.updateScroll(),projection.updateLayout()),measureDragConstraints();let stopResizeListener=addDomEvent(window,"resize",()=>this.scalePositionWithinConstraints()),stopLayoutUpdateListener=projection.addEventListener("didUpdate",({delta,hasLayoutChanged})=>{this.isDragging&&hasLayoutChanged&&(eachAxis(axis=>{let motionValue=this.getAxisMotionValue(axis);motionValue&&(this.originPoint[axis]+=delta[axis].translate,motionValue.set(motionValue.get()+delta[axis].translate))}),this.visualElement.render())});return()=>{stopResizeListener(),stopPointerListener(),stopMeasureLayoutListener(),null==stopLayoutUpdateListener||stopLayoutUpdateListener()}}getProps(){let props=this.visualElement.getProps(),{drag=!1,dragDirectionLock=!1,dragPropagation=!1,dragConstraints=!1,dragElastic=.35,dragMomentum=!0}=props;return{...props,drag,dragDirectionLock,dragPropagation,dragConstraints,dragElastic,dragMomentum}}}function shouldDrag(direction,drag,currentDirection){return(!0===drag||drag===direction)&&(null===currentDirection||currentDirection===direction)}let drag={pan:makeRenderlessComponent(function({onPan,onPanStart,onPanEnd,onPanSessionStart,visualElement}){let panSession=(0,react.useRef)(null),{transformPagePoint}=(0,react.useContext)(MotionConfigContext),handlers={onSessionStart:onPanSessionStart,onStart:onPanStart,onMove:onPan,onEnd(event,info){panSession.current=null,onPanEnd&&onPanEnd(event,info)}};(0,react.useEffect)(()=>{null!==panSession.current&&panSession.current.updateHandlers(handlers)}),usePointerEvent(visualElement,"pointerdown",(onPan||onPanStart||onPanEnd||onPanSessionStart)&&function(event){panSession.current=new PanSession(event,handlers,{transformPagePoint})}),useUnmountEffect(()=>panSession.current&&panSession.current.end())}),drag:makeRenderlessComponent(function(props){let{dragControls:groupDragControls,visualElement}=props,dragControls=useConstant(()=>new VisualElementDragControls(visualElement));(0,react.useEffect)(()=>groupDragControls&&groupDragControls.subscribe(dragControls),[dragControls,groupDragControls]),(0,react.useEffect)(()=>dragControls.addListeners(),[dragControls])})};function css_variables_conversion_isCSSVariable(value){return"string"==typeof value&&value.startsWith("var(--")}let cssVariableRegex=/var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/;function getVariableValue(current,element,depth=1){invariant(depth<=4,`Max CSS variable fallback depth detected in property "${current}". This may indicate a circular fallback dependency.`);let[token,fallback]=function(current){let match=cssVariableRegex.exec(current);if(!match)return[,];let[,token,fallback]=match;return[token,fallback]}(current);if(!token)return;let resolved=window.getComputedStyle(element).getPropertyValue(token);return resolved?resolved.trim():css_variables_conversion_isCSSVariable(fallback)?getVariableValue(fallback,element,depth+1):fallback}let positionalKeys=new Set(["width","height","top","left","right","bottom","x","y"]),isPositionalKey=key=>positionalKeys.has(key),hasPositionalKey=target=>Object.keys(target).some(isPositionalKey),setAndResetVelocity=(value,to)=>{value.set(to,!1),value.set(to)},isNumOrPxType=v=>v===number||v===px;(BoundingBoxDimension=BoundingBoxDimension1||(BoundingBoxDimension1={})).width="width",BoundingBoxDimension.height="height",BoundingBoxDimension.left="left",BoundingBoxDimension.right="right",BoundingBoxDimension.top="top",BoundingBoxDimension.bottom="bottom";let getPosFromMatrix=(matrix,pos)=>parseFloat(matrix.split(", ")[pos]),getTranslateFromMatrix=(pos2,pos3)=>(_bbox,{transform})=>{if("none"===transform||!transform)return 0;let matrix3d=transform.match(/^matrix3d\((.+)\)$/);if(matrix3d)return getPosFromMatrix(matrix3d[1],pos3);{let matrix=transform.match(/^matrix\((.+)\)$/);return matrix?getPosFromMatrix(matrix[1],pos2):0}},transformKeys=new Set(["x","y","z"]),nonTranslationalTransformKeys=transformPropOrder.filter(key=>!transformKeys.has(key)),positionalValues={width:({x},{paddingLeft="0",paddingRight="0"})=>x.max-x.min-parseFloat(paddingLeft)-parseFloat(paddingRight),height:({y},{paddingTop="0",paddingBottom="0"})=>y.max-y.min-parseFloat(paddingTop)-parseFloat(paddingBottom),top:(_bbox,{top})=>parseFloat(top),left:(_bbox,{left})=>parseFloat(left),bottom:({y},{top})=>parseFloat(top)+(y.max-y.min),right:({x},{left})=>parseFloat(left)+(x.max-x.min),x:getTranslateFromMatrix(4,13),y:getTranslateFromMatrix(5,14)},convertChangedValueTypes=(target,visualElement,changedKeys)=>{let originBbox=visualElement.measureViewportBox(),element=visualElement.current,elementComputedStyle=getComputedStyle(element),{display}=elementComputedStyle,origin={};"none"===display&&visualElement.setStaticValue("display",target.display||"block"),changedKeys.forEach(key=>{origin[key]=positionalValues[key](originBbox,elementComputedStyle)}),visualElement.render();let targetBbox=visualElement.measureViewportBox();return changedKeys.forEach(key=>{let value=visualElement.getValue(key);setAndResetVelocity(value,origin[key]),target[key]=positionalValues[key](targetBbox,elementComputedStyle)}),target},checkAndConvertChangedValueTypes=(visualElement,target,origin={},transitionEnd={})=>{target={...target},transitionEnd={...transitionEnd};let targetPositionalKeys=Object.keys(target).filter(isPositionalKey),removedTransformValues=[],hasAttemptedToRemoveTransformValues=!1,changedValueTypeKeys=[];if(targetPositionalKeys.forEach(key=>{let toType;let value=visualElement.getValue(key);if(!visualElement.hasValue(key))return;let from=origin[key],fromType=findDimensionValueType(from),to=target[key];if(isKeyframesTarget(to)){let numKeyframes=to.length,fromIndex=null===to[0]?1:0;fromType=findDimensionValueType(from=to[fromIndex]);for(let i=fromIndex;i<numKeyframes;i++)toType?invariant(findDimensionValueType(to[i])===toType,"All keyframes must be of the same type"):invariant((toType=findDimensionValueType(to[i]))===fromType||isNumOrPxType(fromType)&&isNumOrPxType(toType),"Keyframes must be of the same dimension as the current value")}else toType=findDimensionValueType(to);if(fromType!==toType){if(isNumOrPxType(fromType)&&isNumOrPxType(toType)){let current=value.get();"string"==typeof current&&value.set(parseFloat(current)),"string"==typeof to?target[key]=parseFloat(to):Array.isArray(to)&&toType===px&&(target[key]=to.map(parseFloat))}else(null==fromType?void 0:fromType.transform)&&(null==toType?void 0:toType.transform)&&(0===from||0===to)?0===from?value.set(toType.transform(from)):target[key]=fromType.transform(to):(hasAttemptedToRemoveTransformValues||(removedTransformValues=function(visualElement){let removedTransforms=[];return nonTranslationalTransformKeys.forEach(key=>{let value=visualElement.getValue(key);void 0!==value&&(removedTransforms.push([key,value.get()]),value.set(key.startsWith("scale")?1:0))}),removedTransforms.length&&visualElement.render(),removedTransforms}(visualElement),hasAttemptedToRemoveTransformValues=!0),changedValueTypeKeys.push(key),transitionEnd[key]=void 0!==transitionEnd[key]?transitionEnd[key]:target[key],setAndResetVelocity(value,to))}}),!changedValueTypeKeys.length)return{target,transitionEnd};{let scrollY=changedValueTypeKeys.indexOf("height")>=0?window.pageYOffset:null,convertedTarget=convertChangedValueTypes(target,visualElement,changedValueTypeKeys);return removedTransformValues.length&&removedTransformValues.forEach(([key,value])=>{visualElement.getValue(key).set(value)}),visualElement.render(),isBrowser&&null!==scrollY&&window.scrollTo({top:scrollY}),{target:convertedTarget,transitionEnd}}},parseDomVariant=(visualElement,target,origin,transitionEnd)=>{var target1,transitionEnd1;let resolved=function(visualElement,{...target},transitionEnd){let element=visualElement.current;if(!(element instanceof Element))return{target,transitionEnd};for(let key in transitionEnd&&(transitionEnd={...transitionEnd}),visualElement.values.forEach(value=>{let current=value.get();if(!css_variables_conversion_isCSSVariable(current))return;let resolved=getVariableValue(current,element);resolved&&value.set(resolved)}),target){let current=target[key];if(!css_variables_conversion_isCSSVariable(current))continue;let resolved=getVariableValue(current,element);resolved&&(target[key]=resolved,transitionEnd&&void 0===transitionEnd[key]&&(transitionEnd[key]=current))}return{target,transitionEnd}}(visualElement,target,transitionEnd);return target=resolved.target,transitionEnd=resolved.transitionEnd,target1=target,transitionEnd1=transitionEnd,hasPositionalKey(target1)?checkAndConvertChangedValueTypes(visualElement,target1,origin,transitionEnd1):{target:target1,transitionEnd:transitionEnd1}},prefersReducedMotion={current:null},hasReducedMotionListener={current:!1},featureNames=Object.keys(featureDefinitions),numFeatures=featureNames.length,propEventHandlers=["AnimationStart","AnimationComplete","Update","Unmount","BeforeLayoutMeasure","LayoutMeasure","LayoutAnimationStart","LayoutAnimationComplete"];class VisualElement{constructor({parent,props,reducedMotionConfig,visualState},options={}){this.current=null,this.children=new Set,this.isVariantNode=!1,this.isControllingVariants=!1,this.shouldReduceMotion=null,this.values=new Map,this.isPresent=!0,this.valueSubscriptions=new Map,this.prevMotionValues={},this.events={},this.propEventSubscriptions={},this.notifyUpdate=()=>this.notify("Update",this.latestValues),this.render=()=>{this.current&&(this.triggerBuild(),this.renderInstance(this.current,this.renderState,this.props.style,this.projection))},this.scheduleRender=()=>sync.render(this.render,!1,!0);let{latestValues,renderState}=visualState;this.latestValues=latestValues,this.baseTarget={...latestValues},this.initialValues=props.initial?{...latestValues}:{},this.renderState=renderState,this.parent=parent,this.props=props,this.depth=parent?parent.depth+1:0,this.reducedMotionConfig=reducedMotionConfig,this.options=options,this.isControllingVariants=isControllingVariants(props),this.isVariantNode=isVariantNode(props),this.isVariantNode&&(this.variantChildren=new Set),this.manuallyAnimateOnMount=Boolean(parent&&parent.current);let{willChange,...initialMotionValues}=this.scrapeMotionValuesFromProps(props);for(let key in initialMotionValues){let value=initialMotionValues[key];void 0!==latestValues[key]&&isMotionValue(value)&&(value.set(latestValues[key],!1),isWillChangeMotionValue(willChange)&&willChange.add(key))}if(props.values)for(let key1 in props.values){let value1=props.values[key1];void 0!==latestValues[key1]&&isMotionValue(value1)&&value1.set(latestValues[key1])}}scrapeMotionValuesFromProps(_props){return{}}mount(instance){var _a;this.current=instance,this.projection&&this.projection.mount(instance),this.parent&&this.isVariantNode&&!this.isControllingVariants&&(this.removeFromVariantTree=null===(_a=this.parent)||void 0===_a?void 0:_a.addVariantChild(this)),this.values.forEach((value,key)=>this.bindToMotionValue(key,value)),hasReducedMotionListener.current||function(){if(hasReducedMotionListener.current=!0,isBrowser){if(window.matchMedia){let motionMediaQuery=window.matchMedia("(prefers-reduced-motion)"),setReducedMotionPreferences=()=>prefersReducedMotion.current=motionMediaQuery.matches;motionMediaQuery.addListener(setReducedMotionPreferences),setReducedMotionPreferences()}else prefersReducedMotion.current=!1}}(),this.shouldReduceMotion="never"!==this.reducedMotionConfig&&("always"===this.reducedMotionConfig||prefersReducedMotion.current),this.parent&&this.parent.children.add(this),this.setProps(this.props)}unmount(){var _a,_b,_c;for(let key in null===(_a=this.projection)||void 0===_a||_a.unmount(),cancelSync.update(this.notifyUpdate),cancelSync.render(this.render),this.valueSubscriptions.forEach(remove=>remove()),null===(_b=this.removeFromVariantTree)||void 0===_b||_b.call(this),null===(_c=this.parent)||void 0===_c||_c.children.delete(this),this.events)this.events[key].clear();this.current=null}bindToMotionValue(key,value){let removeOnChange=value.onChange(latestValue=>{this.latestValues[key]=latestValue,this.props.onUpdate&&sync.update(this.notifyUpdate,!1,!0)}),removeOnRenderRequest=value.onRenderRequest(this.scheduleRender);this.valueSubscriptions.set(key,()=>{removeOnChange(),removeOnRenderRequest()})}sortNodePosition(other){return this.current&&this.sortInstanceNodePosition&&this.type===other.type?this.sortInstanceNodePosition(this.current,other.current):0}loadFeatures(renderedProps,isStrict,preloadedFeatures,projectionId,ProjectionNodeConstructor,initialLayoutGroupConfig){let features=[];"production"!==env&&preloadedFeatures&&isStrict&&invariant(!1,"You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.");for(let i=0;i<numFeatures;i++){let name=featureNames[i],{isEnabled,Component}=featureDefinitions[name];isEnabled(renderedProps)&&Component&&features.push((0,react.createElement)(Component,{key:name,...renderedProps,visualElement:this}))}if(!this.projection&&ProjectionNodeConstructor){this.projection=new ProjectionNodeConstructor(projectionId,this.latestValues,this.parent&&this.parent.projection);let{layoutId,layout,drag,dragConstraints,layoutScroll}=renderedProps;this.projection.setOptions({layoutId,layout,alwaysMeasureLayout:Boolean(drag)||dragConstraints&&isRefObject(dragConstraints),visualElement:this,scheduleRender:()=>this.scheduleRender(),animationType:"string"==typeof layout?layout:"both",initialPromotionConfig:initialLayoutGroupConfig,layoutScroll})}return features}triggerBuild(){this.build(this.renderState,this.latestValues,this.options,this.props)}measureViewportBox(){return this.current?this.measureInstanceViewportBox(this.current,this.props):createBox()}getStaticValue(key){return this.latestValues[key]}setStaticValue(key,value){this.latestValues[key]=value}makeTargetAnimatable(target,canMutate=!0){return this.makeTargetAnimatableFromInstance(target,this.props,canMutate)}setProps(props){(props.transformTemplate||this.props.transformTemplate)&&this.scheduleRender(),this.props=props;for(let i=0;i<propEventHandlers.length;i++){let key=propEventHandlers[i];this.propEventSubscriptions[key]&&(this.propEventSubscriptions[key](),delete this.propEventSubscriptions[key]);let listener=props["on"+key];listener&&(this.propEventSubscriptions[key]=this.on(key,listener))}this.prevMotionValues=function(element,next,prev){let{willChange}=next;for(let key in next){let nextValue=next[key],prevValue=prev[key];if(isMotionValue(nextValue))element.addValue(key,nextValue),isWillChangeMotionValue(willChange)&&willChange.add(key);else if(isMotionValue(prevValue))element.addValue(key,motionValue(nextValue)),isWillChangeMotionValue(willChange)&&willChange.remove(key);else if(prevValue!==nextValue){if(element.hasValue(key)){let existingValue=element.getValue(key);existingValue.hasAnimated||existingValue.set(nextValue)}else{let latestValue=element.getStaticValue(key);element.addValue(key,motionValue(void 0!==latestValue?latestValue:nextValue))}}}for(let key1 in prev)void 0===next[key1]&&element.removeValue(key1);return next}(this,this.scrapeMotionValuesFromProps(props),this.prevMotionValues)}getProps(){return this.props}getVariant(name){var _a;return null===(_a=this.props.variants)||void 0===_a?void 0:_a[name]}getDefaultTransition(){return this.props.transition}getTransformPagePoint(){return this.props.transformPagePoint}getClosestVariantNode(){var _a;return this.isVariantNode?this:null===(_a=this.parent)||void 0===_a?void 0:_a.getClosestVariantNode()}getVariantContext(startAtParent=!1){var _a,_b;if(startAtParent)return null===(_a=this.parent)||void 0===_a?void 0:_a.getVariantContext();if(!this.isControllingVariants){let context=(null===(_b=this.parent)||void 0===_b?void 0:_b.getVariantContext())||{};return void 0!==this.props.initial&&(context.initial=this.props.initial),context}let context1={};for(let i=0;i<numVariantProps;i++){let name=VisualElement_variantProps[i],prop=this.props[name];(isVariantLabel(prop)||!1===prop)&&(context1[name]=prop)}return context1}addVariantChild(child){var _a;let closestVariantNode=this.getClosestVariantNode();if(closestVariantNode)return null===(_a=closestVariantNode.variantChildren)||void 0===_a||_a.add(child),()=>closestVariantNode.variantChildren.delete(child)}addValue(key,value){this.hasValue(key)&&this.removeValue(key),this.values.set(key,value),this.latestValues[key]=value.get(),this.bindToMotionValue(key,value)}removeValue(key){var _a;this.values.delete(key),null===(_a=this.valueSubscriptions.get(key))||void 0===_a||_a(),this.valueSubscriptions.delete(key),delete this.latestValues[key],this.removeValueFromRenderState(key,this.renderState)}hasValue(key){return this.values.has(key)}getValue(key,defaultValue){if(this.props.values&&this.props.values[key])return this.props.values[key];let value=this.values.get(key);return void 0===value&&void 0!==defaultValue&&(value=motionValue(defaultValue),this.addValue(key,value)),value}readValue(key){return void 0===this.latestValues[key]&&this.current?this.readValueFromInstance(this.current,key,this.options):this.latestValues[key]}setBaseTarget(key,value){this.baseTarget[key]=value}getBaseTarget(key){var _a;let{initial}=this.props,valueFromInitial="string"==typeof initial||"object"==typeof initial?null===(_a=resolveVariantFromProps(this.props,initial))||void 0===_a?void 0:_a[key]:void 0;if(initial&&void 0!==valueFromInitial)return valueFromInitial;let target=this.getBaseTargetFromProps(this.props,key);return void 0===target||isMotionValue(target)?void 0!==this.initialValues[key]&&void 0===valueFromInitial?void 0:this.baseTarget[key]:target}on(eventName,callback){return this.events[eventName]||(this.events[eventName]=new SubscriptionManager),this.events[eventName].add(callback)}notify(eventName,...args){var _a;null===(_a=this.events[eventName])||void 0===_a||_a.notify(...args)}}let VisualElement_variantProps=["initial",...variantPriorityOrder],numVariantProps=VisualElement_variantProps.length;class DOMVisualElement extends VisualElement{sortInstanceNodePosition(a,b){return 2&a.compareDocumentPosition(b)?1:-1}getBaseTargetFromProps(props,key){var _a;return null===(_a=props.style)||void 0===_a?void 0:_a[key]}removeValueFromRenderState(key,{vars,style}){delete vars[key],delete style[key]}makeTargetAnimatableFromInstance({transition,transitionEnd,...target},{transformValues},isMounted){let origin=function(target,transition,visualElement){var _a;let origin={};for(let key in target){let transitionOrigin=function(key,transition){if(!transition)return;let valueTransition=transition[key]||transition.default||transition;return valueTransition.from}(key,transition);origin[key]=void 0!==transitionOrigin?transitionOrigin:null===(_a=visualElement.getValue(key))||void 0===_a?void 0:_a.get()}return origin}(target,transition||{},this);if(transformValues&&(transitionEnd&&(transitionEnd=transformValues(transitionEnd)),target&&(target=transformValues(target)),origin&&(origin=transformValues(origin))),isMounted){!function(visualElement,target,origin){var _a,_b;let newValueKeys=Object.keys(target).filter(key=>!visualElement.hasValue(key)),numNewValues=newValueKeys.length;if(numNewValues)for(let i=0;i<numNewValues;i++){let key=newValueKeys[i],targetValue=target[key],value=null;Array.isArray(targetValue)&&(value=targetValue[0]),null===value&&(value=null!==(_b=null!==(_a=origin[key])&&void 0!==_a?_a:visualElement.readValue(key))&&void 0!==_b?_b:target[key]),null!=value&&("string"==typeof value&&(isNumericalString(value)||isZeroValueString(value))?value=parseFloat(value):!findValueType(value)&&complex.test(targetValue)&&(value=animatable_none_getAnimatableNone(key,targetValue)),visualElement.addValue(key,motionValue(value)),void 0===origin[key]&&(origin[key]=value),null!==value&&visualElement.setBaseTarget(key,value))}}(this,target,origin);let parsed=parseDomVariant(this,target,origin,transitionEnd);transitionEnd=parsed.transitionEnd,target=parsed.target}return{transition,transitionEnd,...target}}}class HTMLVisualElement extends DOMVisualElement{readValueFromInstance(instance,key){if(transformProps.has(key)){let defaultType=getDefaultValueType(key);return defaultType&&defaultType.default||0}{let computedStyle=window.getComputedStyle(instance),value=(isCSSVariable(key)?computedStyle.getPropertyValue(key):computedStyle[key])||0;return"string"==typeof value?value.trim():value}}measureInstanceViewportBox(instance,{transformPagePoint}){return measureViewportBox(instance,transformPagePoint)}build(renderState,latestValues,options,props){buildHTMLStyles(renderState,latestValues,options,props.transformTemplate)}scrapeMotionValuesFromProps(props){return scrapeMotionValuesFromProps(props)}renderInstance(instance,renderState,styleProp,projection){renderHTML(instance,renderState,styleProp,projection)}}class SVGVisualElement extends DOMVisualElement{getBaseTargetFromProps(props,key){return props[key]}readValueFromInstance(instance,key){var _a;return transformProps.has(key)?(null===(_a=getDefaultValueType(key))||void 0===_a?void 0:_a.default)||0:(key=camelCaseAttributes.has(key)?key:camelToDash(key),instance.getAttribute(key))}measureInstanceViewportBox(){return createBox()}scrapeMotionValuesFromProps(props){return scrape_motion_values_scrapeMotionValuesFromProps(props)}build(renderState,latestValues,options,props){buildSVGAttrs(renderState,latestValues,options,props.transformTemplate)}renderInstance(instance,renderState,styleProp,projection){renderSVG(instance,renderState,styleProp,projection)}}let create_visual_element_createDomVisualElement=(Component,options)=>isSVGComponent(Component)?new SVGVisualElement(options,{enableHardwareAcceleration:!1}):new HTMLVisualElement(options,{enableHardwareAcceleration:!0});function pixelsToPercent(pixels,axis){return axis.max===axis.min?0:pixels/(axis.max-axis.min)*100}let correctBorderRadius={correct(latest,node){if(!node.target)return latest;if("string"==typeof latest){if(!px.test(latest))return latest;latest=parseFloat(latest)}let x=pixelsToPercent(latest,node.target.x),y=pixelsToPercent(latest,node.target.y);return`${x}% ${y}%`}},varToken="_$css";class MeasureLayoutWithContext extends react.Component{componentDidMount(){let{visualElement,layoutGroup,switchLayoutGroup,layoutId}=this.props,{projection}=visualElement;Object.assign(scaleCorrectors,defaultScaleCorrectors),projection&&(layoutGroup.group&&layoutGroup.group.add(projection),switchLayoutGroup&&switchLayoutGroup.register&&layoutId&&switchLayoutGroup.register(projection),projection.root.didUpdate(),projection.addEventListener("animationComplete",()=>{this.safeToRemove()}),projection.setOptions({...projection.options,onExitComplete:()=>this.safeToRemove()})),globalProjectionState.hasEverUpdated=!0}getSnapshotBeforeUpdate(prevProps){let{layoutDependency,visualElement,drag,isPresent}=this.props,projection=visualElement.projection;return projection&&(projection.isPresent=isPresent,drag||prevProps.layoutDependency!==layoutDependency||void 0===layoutDependency?projection.willUpdate():this.safeToRemove(),prevProps.isPresent===isPresent||(isPresent?projection.promote():projection.relegate()||sync.postRender(()=>{var _a;(null===(_a=projection.getStack())||void 0===_a?void 0:_a.members.length)||this.safeToRemove()}))),null}componentDidUpdate(){let{projection}=this.props.visualElement;projection&&(projection.root.didUpdate(),!projection.currentAnimation&&projection.isLead()&&this.safeToRemove())}componentWillUnmount(){let{visualElement,layoutGroup,switchLayoutGroup:promoteContext}=this.props,{projection}=visualElement;projection&&(projection.scheduleCheckAfterUnmount(),(null==layoutGroup?void 0:layoutGroup.group)&&layoutGroup.group.remove(projection),(null==promoteContext?void 0:promoteContext.deregister)&&promoteContext.deregister(projection))}safeToRemove(){let{safeToRemove}=this.props;null==safeToRemove||safeToRemove()}render(){return null}}let defaultScaleCorrectors={borderRadius:{...correctBorderRadius,applyTo:["borderTopLeftRadius","borderTopRightRadius","borderBottomLeftRadius","borderBottomRightRadius"]},borderTopLeftRadius:correctBorderRadius,borderTopRightRadius:correctBorderRadius,borderBottomLeftRadius:correctBorderRadius,borderBottomRightRadius:correctBorderRadius,boxShadow:{correct(latest,{treeScale,projectionDelta}){let original=latest,containsCSSVariables=latest.includes("var("),cssVariables=[];containsCSSVariables&&(latest=latest.replace(cssVariableRegex,match=>(cssVariables.push(match),varToken)));let shadow=complex.parse(latest);if(shadow.length>5)return original;let template=complex.createTransformer(latest),offset="number"!=typeof shadow[0]?1:0,xScale=projectionDelta.x.scale*treeScale.x,yScale=projectionDelta.y.scale*treeScale.y;shadow[0+offset]/=xScale,shadow[1+offset]/=yScale;let averageScale=mix(xScale,yScale,.5);"number"==typeof shadow[2+offset]&&(shadow[2+offset]/=averageScale),"number"==typeof shadow[3+offset]&&(shadow[3+offset]/=averageScale);let output=template(shadow);if(containsCSSVariables){let i=0;output=output.replace(varToken,()=>{let cssVariable=cssVariables[i];return i++,cssVariable})}return output}}},borders=["TopLeft","TopRight","BottomLeft","BottomRight"],numBorders=borders.length,asNumber=value=>"string"==typeof value?parseFloat(value):value,isPx=value=>"number"==typeof value||px.test(value);function getRadius(values,radiusName){var _a;return null!==(_a=values[radiusName])&&void 0!==_a?_a:values.borderRadius}let easeCrossfadeIn=compress(0,.5,circOut),easeCrossfadeOut=compress(.5,.95,linear);function compress(min,max,easing){return p=>p<min?0:p>max?1:easing(progress(min,max,p))}function copyAxisInto(axis,originAxis){axis.min=originAxis.min,axis.max=originAxis.max}function copyBoxInto(box,originBox){copyAxisInto(box.x,originBox.x),copyAxisInto(box.y,originBox.y)}function removePointDelta(point,translate,scale,originPoint,boxScale){return point-=translate,point=originPoint+1/scale*(point-originPoint),void 0!==boxScale&&(point=originPoint+1/boxScale*(point-originPoint)),point}function removeAxisTransforms(axis,transforms,[key,scaleKey,originKey],origin,sourceAxis){!function(axis,translate=0,scale=1,origin=.5,boxScale,originAxis=axis,sourceAxis=axis){if(percent.test(translate)){translate=parseFloat(translate);let relativeProgress=mix(sourceAxis.min,sourceAxis.max,translate/100);translate=relativeProgress-sourceAxis.min}if("number"!=typeof translate)return;let originPoint=mix(originAxis.min,originAxis.max,origin);axis===originAxis&&(originPoint-=translate),axis.min=removePointDelta(axis.min,translate,scale,originPoint,boxScale),axis.max=removePointDelta(axis.max,translate,scale,originPoint,boxScale)}(axis,transforms[key],transforms[scaleKey],transforms[originKey],transforms.scale,origin,sourceAxis)}let delta_remove_xKeys=["x","scaleX","originX"],delta_remove_yKeys=["y","scaleY","originY"];function removeBoxTransforms(box,transforms,originBox,sourceBox){removeAxisTransforms(box.x,transforms,delta_remove_xKeys,null==originBox?void 0:originBox.x,null==sourceBox?void 0:sourceBox.x),removeAxisTransforms(box.y,transforms,delta_remove_yKeys,null==originBox?void 0:originBox.y,null==sourceBox?void 0:sourceBox.y)}function isAxisDeltaZero(delta){return 0===delta.translate&&1===delta.scale}function isDeltaZero(delta){return isAxisDeltaZero(delta.x)&&isAxisDeltaZero(delta.y)}function boxEquals(a,b){return a.x.min===b.x.min&&a.x.max===b.x.max&&a.y.min===b.y.min&&a.y.max===b.y.max}function aspectRatio(box){return calcLength(box.x)/calcLength(box.y)}class NodeStack{constructor(){this.members=[]}add(node){addUniqueItem(this.members,node),node.scheduleRender()}remove(node){if(removeItem(this.members,node),node===this.prevLead&&(this.prevLead=void 0),node===this.lead){let prevLead=this.members[this.members.length-1];prevLead&&this.promote(prevLead)}}relegate(node){let prevLead;let indexOfNode=this.members.findIndex(member=>node===member);if(0===indexOfNode)return!1;for(let i=indexOfNode;i>=0;i--){let member=this.members[i];if(!1!==member.isPresent){prevLead=member;break}}return!!prevLead&&(this.promote(prevLead),!0)}promote(node,preserveFollowOpacity){var _a;let prevLead=this.lead;if(node!==prevLead&&(this.prevLead=prevLead,this.lead=node,node.show(),prevLead)){prevLead.instance&&prevLead.scheduleRender(),node.scheduleRender(),node.resumeFrom=prevLead,preserveFollowOpacity&&(node.resumeFrom.preserveOpacity=!0),prevLead.snapshot&&(node.snapshot=prevLead.snapshot,node.snapshot.latestValues=prevLead.animationValues||prevLead.latestValues,node.snapshot.isShared=!0),(null===(_a=node.root)||void 0===_a?void 0:_a.isUpdating)&&(node.isLayoutDirty=!0);let{crossfade}=node.options;!1===crossfade&&prevLead.hide()}}exitAnimationComplete(){this.members.forEach(node=>{var _a,_b,_c,_d,_e;null===(_b=(_a=node.options).onExitComplete)||void 0===_b||_b.call(_a),null===(_e=null===(_c=node.resumingFrom)||void 0===_c?void 0:(_d=_c.options).onExitComplete)||void 0===_e||_e.call(_d)})}scheduleRender(){this.members.forEach(node=>{node.instance&&node.scheduleRender(!1)})}removeLeadSnapshot(){this.lead&&this.lead.snapshot&&(this.lead.snapshot=void 0)}}function buildProjectionTransform(delta,treeScale,latestTransform){let xTranslate=delta.x.translate/treeScale.x,yTranslate=delta.y.translate/treeScale.y,transform=`translate3d(${xTranslate}px, ${yTranslate}px, 0) `;if(transform+=`scale(${1/treeScale.x}, ${1/treeScale.y}) `,latestTransform){let{rotate,rotateX,rotateY}=latestTransform;rotate&&(transform+=`rotate(${rotate}deg) `),rotateX&&(transform+=`rotateX(${rotateX}deg) `),rotateY&&(transform+=`rotateY(${rotateY}deg) `)}let elementScaleX=delta.x.scale*treeScale.x,elementScaleY=delta.y.scale*treeScale.y;return"translate3d(0px, 0px, 0) scale(1, 1) scale(1, 1)"==(transform+=`scale(${elementScaleX}, ${elementScaleY})`)?"none":transform}let compareByDepth=(a,b)=>a.depth-b.depth;class FlatTree{constructor(){this.children=[],this.isDirty=!1}add(child){addUniqueItem(this.children,child),this.isDirty=!0}remove(child){removeItem(this.children,child),this.isDirty=!0}forEach(callback){this.isDirty&&this.children.sort(compareByDepth),this.isDirty=!1,this.children.forEach(callback)}}let transformAxes=["","X","Y","Z"];function createProjectionNode({attachResizeListener,defaultParent,measureScroll,checkIsScrollRoot,resetTransform}){return class{constructor(elementId,latestValues={},parent=null==defaultParent?void 0:defaultParent()){this.children=new Set,this.options={},this.isTreeAnimating=!1,this.isAnimationBlocked=!1,this.isLayoutDirty=!1,this.updateManuallyBlocked=!1,this.updateBlockedByResize=!1,this.isUpdating=!1,this.isSVG=!1,this.needsReset=!1,this.shouldResetTransform=!1,this.treeScale={x:1,y:1},this.eventHandlers=new Map,this.potentialNodes=new Map,this.checkUpdateFailed=()=>{this.isUpdating&&(this.isUpdating=!1,this.clearAllSnapshots())},this.updateProjection=()=>{this.nodes.forEach(resolveTargetDelta),this.nodes.forEach(calcProjection)},this.hasProjected=!1,this.isVisible=!0,this.animationProgress=0,this.sharedNodes=new Map,this.elementId=elementId,this.latestValues=latestValues,this.root=parent?parent.root||parent:this,this.path=parent?[...parent.path,parent]:[],this.parent=parent,this.depth=parent?parent.depth+1:0,elementId&&this.root.registerPotentialNode(elementId,this);for(let i=0;i<this.path.length;i++)this.path[i].shouldResetTransform=!0;this.root===this&&(this.nodes=new FlatTree)}addEventListener(name,handler){return this.eventHandlers.has(name)||this.eventHandlers.set(name,new SubscriptionManager),this.eventHandlers.get(name).add(handler)}notifyListeners(name,...args){let subscriptionManager=this.eventHandlers.get(name);null==subscriptionManager||subscriptionManager.notify(...args)}hasListeners(name){return this.eventHandlers.has(name)}registerPotentialNode(id,node){this.potentialNodes.set(id,node)}mount(instance,isLayoutDirty=!1){var _a;if(this.instance)return;this.isSVG=instance instanceof SVGElement&&"svg"!==instance.tagName,this.instance=instance;let{layoutId,layout,visualElement}=this.options;if(visualElement&&!visualElement.current&&visualElement.mount(instance),this.root.nodes.add(this),null===(_a=this.parent)||void 0===_a||_a.children.add(this),this.elementId&&this.root.potentialNodes.delete(this.elementId),isLayoutDirty&&(layout||layoutId)&&(this.isLayoutDirty=!0),attachResizeListener){let cancelDelay;let resizeUnblockUpdate=()=>this.root.updateBlockedByResize=!1;attachResizeListener(instance,()=>{this.root.updateBlockedByResize=!0,cancelDelay&&cancelDelay(),cancelDelay=delay(resizeUnblockUpdate,250),globalProjectionState.hasAnimatedSinceResize&&(globalProjectionState.hasAnimatedSinceResize=!1,this.nodes.forEach(finishAnimation))})}layoutId&&this.root.registerSharedNode(layoutId,this),!1!==this.options.animate&&visualElement&&(layoutId||layout)&&this.addEventListener("didUpdate",({delta,hasLayoutChanged,hasRelativeTargetChanged,layout:newLayout})=>{var _a,_b,_c,_d,_e;if(this.isTreeAnimationBlocked()){this.target=void 0,this.relativeTarget=void 0;return}let layoutTransition=null!==(_b=null!==(_a=this.options.transition)&&void 0!==_a?_a:visualElement.getDefaultTransition())&&void 0!==_b?_b:defaultLayoutTransition,{onLayoutAnimationStart,onLayoutAnimationComplete}=visualElement.getProps(),targetChanged=!this.targetLayout||!boxEquals(this.targetLayout,newLayout)||hasRelativeTargetChanged,hasOnlyRelativeTargetChanged=!hasLayoutChanged&&hasRelativeTargetChanged;if((null===(_c=this.resumeFrom)||void 0===_c?void 0:_c.instance)||hasOnlyRelativeTargetChanged||hasLayoutChanged&&(targetChanged||!this.currentAnimation)){this.resumeFrom&&(this.resumingFrom=this.resumeFrom,this.resumingFrom.resumingFrom=void 0),this.setAnimationOrigin(delta,hasOnlyRelativeTargetChanged);let animationOptions={...getValueTransition(layoutTransition,"layout"),onPlay:onLayoutAnimationStart,onComplete:onLayoutAnimationComplete};visualElement.shouldReduceMotion&&(animationOptions.delay=0,animationOptions.type=!1),this.startAnimation(animationOptions)}else hasLayoutChanged||0!==this.animationProgress||finishAnimation(this),this.isLead()&&(null===(_e=(_d=this.options).onExitComplete)||void 0===_e||_e.call(_d));this.targetLayout=newLayout})}unmount(){var _a,_b;this.options.layoutId&&this.willUpdate(),this.root.nodes.remove(this),null===(_a=this.getStack())||void 0===_a||_a.remove(this),null===(_b=this.parent)||void 0===_b||_b.children.delete(this),this.instance=void 0,cancelSync.preRender(this.updateProjection)}blockUpdate(){this.updateManuallyBlocked=!0}unblockUpdate(){this.updateManuallyBlocked=!1}isUpdateBlocked(){return this.updateManuallyBlocked||this.updateBlockedByResize}isTreeAnimationBlocked(){var _a;return this.isAnimationBlocked||(null===(_a=this.parent)||void 0===_a?void 0:_a.isTreeAnimationBlocked())||!1}startUpdate(){var _a;this.isUpdateBlocked()||(this.isUpdating=!0,null===(_a=this.nodes)||void 0===_a||_a.forEach(resetRotation))}willUpdate(shouldNotifyListeners=!0){var _a,_b,_c;if(this.root.isUpdateBlocked()){null===(_b=(_a=this.options).onExitComplete)||void 0===_b||_b.call(_a);return}if(this.root.isUpdating||this.root.startUpdate(),this.isLayoutDirty)return;this.isLayoutDirty=!0;for(let i=0;i<this.path.length;i++){let node=this.path[i];node.shouldResetTransform=!0,node.updateScroll()}let{layoutId,layout}=this.options;if(void 0===layoutId&&!layout)return;let transformTemplate=null===(_c=this.options.visualElement)||void 0===_c?void 0:_c.getProps().transformTemplate;this.prevTransformTemplateValue=null==transformTemplate?void 0:transformTemplate(this.latestValues,""),this.updateSnapshot(),shouldNotifyListeners&&this.notifyListeners("willUpdate")}didUpdate(){let updateWasBlocked=this.isUpdateBlocked();if(updateWasBlocked){this.unblockUpdate(),this.clearAllSnapshots(),this.nodes.forEach(clearMeasurements);return}this.isUpdating&&(this.isUpdating=!1,this.potentialNodes.size&&(this.potentialNodes.forEach(mountNodeEarly),this.potentialNodes.clear()),this.nodes.forEach(resetTransformStyle),this.nodes.forEach(updateLayout),this.nodes.forEach(notifyLayoutUpdate),this.clearAllSnapshots(),flushSync.update(),flushSync.preRender(),flushSync.render())}clearAllSnapshots(){this.nodes.forEach(clearSnapshot),this.sharedNodes.forEach(removeLeadSnapshots)}scheduleUpdateProjection(){sync.preRender(this.updateProjection,!1,!0)}scheduleCheckAfterUnmount(){sync.postRender(()=>{this.isLayoutDirty?this.root.didUpdate():this.root.checkUpdateFailed()})}updateSnapshot(){!this.snapshot&&this.instance&&(this.snapshot=this.measure())}updateLayout(){var _a;if(!this.instance||(this.updateScroll(),!(this.options.alwaysMeasureLayout&&this.isLead())&&!this.isLayoutDirty))return;if(this.resumeFrom&&!this.resumeFrom.instance)for(let i=0;i<this.path.length;i++){let node=this.path[i];node.updateScroll()}let prevLayout=this.layout;this.layout=this.measure(!1),this.layoutCorrected=createBox(),this.isLayoutDirty=!1,this.projectionDelta=void 0,this.notifyListeners("measure",this.layout.layoutBox),null===(_a=this.options.visualElement)||void 0===_a||_a.notify("LayoutMeasure",this.layout.layoutBox,null==prevLayout?void 0:prevLayout.layoutBox)}updateScroll(){this.options.layoutScroll&&this.instance&&(this.isScrollRoot=checkIsScrollRoot(this.instance),this.scroll=measureScroll(this.instance))}resetTransform(){var _a;if(!resetTransform)return;let isResetRequested=this.isLayoutDirty||this.shouldResetTransform,hasProjection=this.projectionDelta&&!isDeltaZero(this.projectionDelta),transformTemplate=null===(_a=this.options.visualElement)||void 0===_a?void 0:_a.getProps().transformTemplate,transformTemplateValue=null==transformTemplate?void 0:transformTemplate(this.latestValues,""),transformTemplateHasChanged=transformTemplateValue!==this.prevTransformTemplateValue;isResetRequested&&(hasProjection||hasTransform(this.latestValues)||transformTemplateHasChanged)&&(resetTransform(this.instance,transformTemplateValue),this.shouldResetTransform=!1,this.scheduleRender())}measure(removeTransform=!0){var box;let pageBox=this.measurePageBox(),layoutBox=this.removeElementScroll(pageBox);return removeTransform&&(layoutBox=this.removeTransform(layoutBox)),roundAxis((box=layoutBox).x),roundAxis(box.y),{measuredBox:pageBox,layoutBox,latestValues:{}}}measurePageBox(){let{visualElement}=this.options;if(!visualElement)return createBox();let box=visualElement.measureViewportBox(),{scroll}=this.root;return scroll&&(translateAxis(box.x,scroll.x),translateAxis(box.y,scroll.y)),box}removeElementScroll(box){let boxWithoutScroll=createBox();copyBoxInto(boxWithoutScroll,box);for(let i=0;i<this.path.length;i++){let node=this.path[i],{scroll,options,isScrollRoot}=node;if(node!==this.root&&scroll&&options.layoutScroll){if(isScrollRoot){copyBoxInto(boxWithoutScroll,box);let{scroll:rootScroll}=this.root;rootScroll&&(translateAxis(boxWithoutScroll.x,-rootScroll.x),translateAxis(boxWithoutScroll.y,-rootScroll.y))}translateAxis(boxWithoutScroll.x,scroll.x),translateAxis(boxWithoutScroll.y,scroll.y)}}return boxWithoutScroll}applyTransform(box,transformOnly=!1){let withTransforms=createBox();copyBoxInto(withTransforms,box);for(let i=0;i<this.path.length;i++){let node=this.path[i];!transformOnly&&node.options.layoutScroll&&node.scroll&&node!==node.root&&transformBox(withTransforms,{x:-node.scroll.x,y:-node.scroll.y}),hasTransform(node.latestValues)&&transformBox(withTransforms,node.latestValues)}return hasTransform(this.latestValues)&&transformBox(withTransforms,this.latestValues),withTransforms}removeTransform(box){var _a;let boxWithoutTransform=createBox();copyBoxInto(boxWithoutTransform,box);for(let i=0;i<this.path.length;i++){let node=this.path[i];if(!node.instance||!hasTransform(node.latestValues))continue;hasScale(node.latestValues)&&node.updateSnapshot();let sourceBox=createBox(),nodeBox=node.measurePageBox();copyBoxInto(sourceBox,nodeBox),removeBoxTransforms(boxWithoutTransform,node.latestValues,null===(_a=node.snapshot)||void 0===_a?void 0:_a.layoutBox,sourceBox)}return hasTransform(this.latestValues)&&removeBoxTransforms(boxWithoutTransform,this.latestValues),boxWithoutTransform}setTargetDelta(delta){this.targetDelta=delta,this.root.scheduleUpdateProjection()}setOptions(options){this.options={...this.options,...options,crossfade:void 0===options.crossfade||options.crossfade}}clearMeasurements(){this.scroll=void 0,this.layout=void 0,this.snapshot=void 0,this.prevTransformTemplateValue=void 0,this.targetDelta=void 0,this.target=void 0,this.isLayoutDirty=!1}resolveTargetDelta(){var _a,target,relative,parent;let{layout,layoutId}=this.options;if(this.layout&&(layout||layoutId)){if(!this.targetDelta&&!this.relativeTarget){let relativeParent=this.getClosestProjectingParent();relativeParent&&relativeParent.layout?(this.relativeParent=relativeParent,this.relativeTarget=createBox(),this.relativeTargetOrigin=createBox(),calcRelativePosition(this.relativeTargetOrigin,this.layout.layoutBox,relativeParent.layout.layoutBox),copyBoxInto(this.relativeTarget,this.relativeTargetOrigin)):this.relativeParent=this.relativeTarget=void 0}if((this.relativeTarget||this.targetDelta)&&((this.target||(this.target=createBox(),this.targetWithTransforms=createBox()),this.relativeTarget&&this.relativeTargetOrigin&&(null===(_a=this.relativeParent)||void 0===_a?void 0:_a.target))?(target=this.target,relative=this.relativeTarget,parent=this.relativeParent.target,calcRelativeAxis(target.x,relative.x,parent.x),calcRelativeAxis(target.y,relative.y,parent.y)):this.targetDelta?(Boolean(this.resumingFrom)?this.target=this.applyTransform(this.layout.layoutBox):copyBoxInto(this.target,this.layout.layoutBox),applyBoxDelta(this.target,this.targetDelta)):copyBoxInto(this.target,this.layout.layoutBox),this.attemptToResolveRelativeTarget)){this.attemptToResolveRelativeTarget=!1;let relativeParent1=this.getClosestProjectingParent();relativeParent1&&Boolean(relativeParent1.resumingFrom)===Boolean(this.resumingFrom)&&!relativeParent1.options.layoutScroll&&relativeParent1.target?(this.relativeParent=relativeParent1,this.relativeTarget=createBox(),this.relativeTargetOrigin=createBox(),calcRelativePosition(this.relativeTargetOrigin,this.target,relativeParent1.target),copyBoxInto(this.relativeTarget,this.relativeTargetOrigin)):this.relativeParent=this.relativeTarget=void 0}}}getClosestProjectingParent(){if(!(!this.parent||hasScale(this.parent.latestValues)||has2DTranslate(this.parent.latestValues)))return(this.parent.relativeTarget||this.parent.targetDelta)&&this.parent.layout?this.parent:this.parent.getClosestProjectingParent()}calcProjection(){var _a;let{layout,layoutId}=this.options;if(this.isTreeAnimating=Boolean((null===(_a=this.parent)||void 0===_a?void 0:_a.isTreeAnimating)||this.currentAnimation||this.pendingAnimation),this.isTreeAnimating||(this.targetDelta=this.relativeTarget=void 0),!this.layout||!(layout||layoutId))return;let lead=this.getLead();copyBoxInto(this.layoutCorrected,this.layout.layoutBox),function(box,treeScale,treePath,isSharedTransition=!1){var _a,_b;let node,delta;let treeLength=treePath.length;if(treeLength){treeScale.x=treeScale.y=1;for(let i=0;i<treeLength;i++)delta=(node=treePath[i]).projectionDelta,(null===(_b=null===(_a=node.instance)||void 0===_a?void 0:_a.style)||void 0===_b?void 0:_b.display)!=="contents"&&(isSharedTransition&&node.options.layoutScroll&&node.scroll&&node!==node.root&&transformBox(box,{x:-node.scroll.x,y:-node.scroll.y}),delta&&(treeScale.x*=delta.x.scale,treeScale.y*=delta.y.scale,applyBoxDelta(box,delta)),isSharedTransition&&hasTransform(node.latestValues)&&transformBox(box,node.latestValues))}}(this.layoutCorrected,this.treeScale,this.path,Boolean(this.resumingFrom)||this!==lead);let{target}=lead;if(!target)return;this.projectionDelta||(this.projectionDelta=createDelta(),this.projectionDeltaWithTransform=createDelta());let prevTreeScaleX=this.treeScale.x,prevTreeScaleY=this.treeScale.y,prevProjectionTransform=this.projectionTransform;calcBoxDelta(this.projectionDelta,this.layoutCorrected,target,this.latestValues),this.projectionTransform=buildProjectionTransform(this.projectionDelta,this.treeScale),(this.projectionTransform!==prevProjectionTransform||this.treeScale.x!==prevTreeScaleX||this.treeScale.y!==prevTreeScaleY)&&(this.hasProjected=!0,this.scheduleRender(),this.notifyListeners("projectionUpdate",target))}hide(){this.isVisible=!1}show(){this.isVisible=!0}scheduleRender(notifyAll=!0){var _a,_b,_c;null===(_b=(_a=this.options).scheduleRender)||void 0===_b||_b.call(_a),notifyAll&&(null===(_c=this.getStack())||void 0===_c||_c.scheduleRender()),this.resumingFrom&&!this.resumingFrom.instance&&(this.resumingFrom=void 0)}setAnimationOrigin(delta,hasOnlyRelativeTargetChanged=!1){var _a;let snapshot=this.snapshot,snapshotLatestValues=(null==snapshot?void 0:snapshot.latestValues)||{},mixedValues={...this.latestValues},targetDelta=createDelta();this.relativeTarget=this.relativeTargetOrigin=void 0,this.attemptToResolveRelativeTarget=!hasOnlyRelativeTargetChanged;let relativeLayout=createBox(),isSharedLayoutAnimation=null==snapshot?void 0:snapshot.isShared,isOnlyMember=1>=((null===(_a=this.getStack())||void 0===_a?void 0:_a.members.length)||0),shouldCrossfadeOpacity=Boolean(isSharedLayoutAnimation&&!isOnlyMember&&!0===this.options.crossfade&&!this.path.some(hasOpacityCrossfade));this.animationProgress=0,this.mixTargetDelta=latest=>{var _a,output,from;let progress=latest/1e3;mixAxisDelta(targetDelta.x,delta.x,progress),mixAxisDelta(targetDelta.y,delta.y,progress),this.setTargetDelta(targetDelta),this.relativeTarget&&this.relativeTargetOrigin&&this.layout&&(null===(_a=this.relativeParent)||void 0===_a?void 0:_a.layout)&&(calcRelativePosition(relativeLayout,this.layout.layoutBox,this.relativeParent.layout.layoutBox),output=this.relativeTarget,from=this.relativeTargetOrigin,mixAxis(output.x,from.x,relativeLayout.x,progress),mixAxis(output.y,from.y,relativeLayout.y,progress)),isSharedLayoutAnimation&&(this.animationValues=mixedValues,function(target,follow,lead,progress,shouldCrossfadeOpacity,isOnlyMember){var _a,_b,_c,_d;shouldCrossfadeOpacity?(target.opacity=mix(0,null!==(_a=lead.opacity)&&void 0!==_a?_a:1,easeCrossfadeIn(progress)),target.opacityExit=mix(null!==(_b=follow.opacity)&&void 0!==_b?_b:1,0,easeCrossfadeOut(progress))):isOnlyMember&&(target.opacity=mix(null!==(_c=follow.opacity)&&void 0!==_c?_c:1,null!==(_d=lead.opacity)&&void 0!==_d?_d:1,progress));for(let i=0;i<numBorders;i++){let borderLabel=`border${borders[i]}Radius`,followRadius=getRadius(follow,borderLabel),leadRadius=getRadius(lead,borderLabel);if(void 0===followRadius&&void 0===leadRadius)continue;followRadius||(followRadius=0),leadRadius||(leadRadius=0);let canMix=0===followRadius||0===leadRadius||isPx(followRadius)===isPx(leadRadius);canMix?(target[borderLabel]=Math.max(mix(asNumber(followRadius),asNumber(leadRadius),progress),0),(percent.test(leadRadius)||percent.test(followRadius))&&(target[borderLabel]+="%")):target[borderLabel]=leadRadius}(follow.rotate||lead.rotate)&&(target.rotate=mix(follow.rotate||0,lead.rotate||0,progress))}(mixedValues,snapshotLatestValues,this.latestValues,progress,shouldCrossfadeOpacity,isOnlyMember)),this.root.scheduleUpdateProjection(),this.scheduleRender(),this.animationProgress=progress},this.mixTargetDelta(0)}startAnimation(options){var _a,_b;this.notifyListeners("animationStart"),null===(_a=this.currentAnimation)||void 0===_a||_a.stop(),this.resumingFrom&&(null===(_b=this.resumingFrom.currentAnimation)||void 0===_b||_b.stop()),this.pendingAnimation&&(cancelSync.update(this.pendingAnimation),this.pendingAnimation=void 0),this.pendingAnimation=sync.update(()=>{globalProjectionState.hasAnimatedSinceResize=!0,this.currentAnimation=function(from,to,transition={}){let value=isMotionValue(from)?from:motionValue(from);return startAnimation("",value,1e3,transition),{stop:()=>value.stop(),isAnimating:()=>value.isAnimating()}}(0,0,{...options,onUpdate:latest=>{var _a;this.mixTargetDelta(latest),null===(_a=options.onUpdate)||void 0===_a||_a.call(options,latest)},onComplete:()=>{var _a;null===(_a=options.onComplete)||void 0===_a||_a.call(options),this.completeAnimation()}}),this.resumingFrom&&(this.resumingFrom.currentAnimation=this.currentAnimation),this.pendingAnimation=void 0})}completeAnimation(){var _a;this.resumingFrom&&(this.resumingFrom.currentAnimation=void 0,this.resumingFrom.preserveOpacity=void 0),null===(_a=this.getStack())||void 0===_a||_a.exitAnimationComplete(),this.resumingFrom=this.currentAnimation=this.animationValues=void 0,this.notifyListeners("animationComplete")}finishAnimation(){var _a;this.currentAnimation&&(null===(_a=this.mixTargetDelta)||void 0===_a||_a.call(this,1e3),this.currentAnimation.stop()),this.completeAnimation()}applyTransformsToTarget(){let lead=this.getLead(),{targetWithTransforms,target,layout,latestValues}=lead;if(targetWithTransforms&&target&&layout){if(this!==lead&&this.layout&&layout&&shouldAnimatePositionOnly(this.options.animationType,this.layout.layoutBox,layout.layoutBox)){target=this.target||createBox();let xLength=calcLength(this.layout.layoutBox.x);target.x.min=lead.target.x.min,target.x.max=target.x.min+xLength;let yLength=calcLength(this.layout.layoutBox.y);target.y.min=lead.target.y.min,target.y.max=target.y.min+yLength}copyBoxInto(targetWithTransforms,target),transformBox(targetWithTransforms,latestValues),calcBoxDelta(this.projectionDeltaWithTransform,this.layoutCorrected,targetWithTransforms,latestValues)}}registerSharedNode(layoutId,node){var _a,_b,_c;this.sharedNodes.has(layoutId)||this.sharedNodes.set(layoutId,new NodeStack);let stack=this.sharedNodes.get(layoutId);stack.add(node),node.promote({transition:null===(_a=node.options.initialPromotionConfig)||void 0===_a?void 0:_a.transition,preserveFollowOpacity:null===(_c=null===(_b=node.options.initialPromotionConfig)||void 0===_b?void 0:_b.shouldPreserveFollowOpacity)||void 0===_c?void 0:_c.call(_b,node)})}isLead(){let stack=this.getStack();return!stack||stack.lead===this}getLead(){var _a;let{layoutId}=this.options;return layoutId&&(null===(_a=this.getStack())||void 0===_a?void 0:_a.lead)||this}getPrevLead(){var _a;let{layoutId}=this.options;return layoutId?null===(_a=this.getStack())||void 0===_a?void 0:_a.prevLead:void 0}getStack(){let{layoutId}=this.options;if(layoutId)return this.root.sharedNodes.get(layoutId)}promote({needsReset,transition,preserveFollowOpacity}={}){let stack=this.getStack();stack&&stack.promote(this,preserveFollowOpacity),needsReset&&(this.projectionDelta=void 0,this.needsReset=!0),transition&&this.setOptions({transition})}relegate(){let stack=this.getStack();return!!stack&&stack.relegate(this)}resetRotation(){let{visualElement}=this.options;if(!visualElement)return;let hasRotate=!1,resetValues={};for(let i=0;i<transformAxes.length;i++){let axis=transformAxes[i],key="rotate"+axis;visualElement.getStaticValue(key)&&(hasRotate=!0,resetValues[key]=visualElement.getStaticValue(key),visualElement.setStaticValue(key,0))}if(hasRotate){for(let key1 in null==visualElement||visualElement.render(),resetValues)visualElement.setStaticValue(key1,resetValues[key1]);visualElement.scheduleRender()}}getProjectionStyles(styleProp={}){var _a,_b,_c;let styles={};if(!this.instance||this.isSVG)return styles;if(!this.isVisible)return{visibility:"hidden"};styles.visibility="";let transformTemplate=null===(_a=this.options.visualElement)||void 0===_a?void 0:_a.getProps().transformTemplate;if(this.needsReset)return this.needsReset=!1,styles.opacity="",styles.pointerEvents=resolveMotionValue(styleProp.pointerEvents)||"",styles.transform=transformTemplate?transformTemplate(this.latestValues,""):"none",styles;let lead=this.getLead();if(!this.projectionDelta||!this.layout||!lead.target){let emptyStyles={};return this.options.layoutId&&(emptyStyles.opacity=void 0!==this.latestValues.opacity?this.latestValues.opacity:1,emptyStyles.pointerEvents=resolveMotionValue(styleProp.pointerEvents)||""),this.hasProjected&&!hasTransform(this.latestValues)&&(emptyStyles.transform=transformTemplate?transformTemplate({},""):"none",this.hasProjected=!1),emptyStyles}let valuesToRender=lead.animationValues||lead.latestValues;this.applyTransformsToTarget(),styles.transform=buildProjectionTransform(this.projectionDeltaWithTransform,this.treeScale,valuesToRender),transformTemplate&&(styles.transform=transformTemplate(valuesToRender,styles.transform));let{x,y}=this.projectionDelta;for(let key in styles.transformOrigin=`${100*x.origin}% ${100*y.origin}% 0`,lead.animationValues?styles.opacity=lead===this?null!==(_c=null!==(_b=valuesToRender.opacity)&&void 0!==_b?_b:this.latestValues.opacity)&&void 0!==_c?_c:1:this.preserveOpacity?this.latestValues.opacity:valuesToRender.opacityExit:styles.opacity=lead===this?void 0!==valuesToRender.opacity?valuesToRender.opacity:"":void 0!==valuesToRender.opacityExit?valuesToRender.opacityExit:0,scaleCorrectors){if(void 0===valuesToRender[key])continue;let{correct,applyTo}=scaleCorrectors[key],corrected=correct(valuesToRender[key],lead);if(applyTo){let num=applyTo.length;for(let i=0;i<num;i++)styles[applyTo[i]]=corrected}else styles[key]=corrected}return this.options.layoutId&&(styles.pointerEvents=lead===this?resolveMotionValue(styleProp.pointerEvents)||"":"none"),styles}clearSnapshot(){this.resumeFrom=this.snapshot=void 0}resetTree(){this.root.nodes.forEach(node=>{var _a;return null===(_a=node.currentAnimation)||void 0===_a?void 0:_a.stop()}),this.root.nodes.forEach(clearMeasurements),this.root.sharedNodes.clear()}}}function updateLayout(node){node.updateLayout()}function notifyLayoutUpdate(node){var _a,_b,_c;let snapshot=(null===(_a=node.resumeFrom)||void 0===_a?void 0:_a.snapshot)||node.snapshot;if(node.isLead()&&node.layout&&snapshot&&node.hasListeners("didUpdate")){let{layoutBox:layout,measuredBox:measuredLayout}=node.layout,{animationType}=node.options;"size"===animationType?eachAxis(axis=>{let axisSnapshot=snapshot.isShared?snapshot.measuredBox[axis]:snapshot.layoutBox[axis],length=calcLength(axisSnapshot);axisSnapshot.min=layout[axis].min,axisSnapshot.max=axisSnapshot.min+length}):shouldAnimatePositionOnly(animationType,snapshot.layoutBox,layout)&&eachAxis(axis=>{let axisSnapshot=snapshot.isShared?snapshot.measuredBox[axis]:snapshot.layoutBox[axis],length=calcLength(layout[axis]);axisSnapshot.max=axisSnapshot.min+length});let layoutDelta=createDelta();calcBoxDelta(layoutDelta,layout,snapshot.layoutBox);let visualDelta=createDelta();snapshot.isShared?calcBoxDelta(visualDelta,node.applyTransform(measuredLayout,!0),snapshot.measuredBox):calcBoxDelta(visualDelta,layout,snapshot.layoutBox);let hasLayoutChanged=!isDeltaZero(layoutDelta),hasRelativeTargetChanged=!1;if(!node.resumeFrom){let relativeParent=node.getClosestProjectingParent();if(relativeParent&&!relativeParent.resumeFrom){let{snapshot:parentSnapshot,layout:parentLayout}=relativeParent;if(parentSnapshot&&parentLayout){let relativeSnapshot=createBox();calcRelativePosition(relativeSnapshot,snapshot.layoutBox,parentSnapshot.layoutBox);let relativeLayout=createBox();calcRelativePosition(relativeLayout,layout,parentLayout.layoutBox),boxEquals(relativeSnapshot,relativeLayout)||(hasRelativeTargetChanged=!0)}}}node.notifyListeners("didUpdate",{layout,snapshot,delta:visualDelta,layoutDelta,hasLayoutChanged,hasRelativeTargetChanged})}else node.isLead()&&(null===(_c=(_b=node.options).onExitComplete)||void 0===_c||_c.call(_b));node.options.transition=void 0}function clearSnapshot(node){node.clearSnapshot()}function clearMeasurements(node){node.clearMeasurements()}function resetTransformStyle(node){let{visualElement}=node.options;(null==visualElement?void 0:visualElement.getProps().onBeforeLayoutMeasure)&&visualElement.notify("BeforeLayoutMeasure"),node.resetTransform()}function finishAnimation(node){node.finishAnimation(),node.targetDelta=node.relativeTarget=node.target=void 0}function resolveTargetDelta(node){node.resolveTargetDelta()}function calcProjection(node){node.calcProjection()}function resetRotation(node){node.resetRotation()}function removeLeadSnapshots(stack){stack.removeLeadSnapshot()}function mixAxisDelta(output,delta,p){output.translate=mix(delta.translate,0,p),output.scale=mix(delta.scale,1,p),output.origin=delta.origin,output.originPoint=delta.originPoint}function mixAxis(output,from,to,p){output.min=mix(from.min,to.min,p),output.max=mix(from.max,to.max,p)}function hasOpacityCrossfade(node){return node.animationValues&&void 0!==node.animationValues.opacityExit}let defaultLayoutTransition={duration:.45,ease:[.4,0,.1,1]};function mountNodeEarly(node,id){let searchNode=node.root;for(let i=node.path.length-1;i>=0;i--)if(Boolean(node.path[i].instance)){searchNode=node.path[i];break}let searchElement=searchNode&&searchNode!==node.root?searchNode.instance:document,element=searchElement.querySelector(`[data-projection-id="${id}"]`);element&&node.mount(element,!0)}function roundAxis(axis){axis.min=Math.round(axis.min),axis.max=Math.round(axis.max)}function shouldAnimatePositionOnly(animationType,snapshot,layout){return"position"===animationType||"preserve-aspect"===animationType&&!function(a,b,max=.1){return distance(a,b)<=max}(aspectRatio(snapshot),aspectRatio(layout),.2)}let DocumentProjectionNode=createProjectionNode({attachResizeListener:(ref,notify)=>addDomEvent(ref,"resize",notify),measureScroll:()=>({x:document.documentElement.scrollLeft||document.body.scrollLeft,y:document.documentElement.scrollTop||document.body.scrollTop}),checkIsScrollRoot:()=>!0}),rootProjectionNode={current:void 0},HTMLProjectionNode_HTMLProjectionNode=createProjectionNode({measureScroll:instance=>({x:instance.scrollLeft,y:instance.scrollTop}),defaultParent(){if(!rootProjectionNode.current){let documentNode=new DocumentProjectionNode(0,{});documentNode.mount(window),documentNode.setOptions({layoutScroll:!0}),rootProjectionNode.current=documentNode}return rootProjectionNode.current},resetTransform(instance,value){instance.style.transform=void 0!==value?value:"none"},checkIsScrollRoot:instance=>Boolean("fixed"===window.getComputedStyle(instance).position)}),featureBundle={...animations,...gestureAnimations,...drag,measureLayout:function(props){let[isPresent,safeToRemove]=usePresence(),layoutGroup=(0,react.useContext)(LayoutGroupContext);return react.createElement(MeasureLayoutWithContext,{...props,layoutGroup:layoutGroup,switchLayoutGroup:(0,react.useContext)(SwitchLayoutGroupContext),isPresent:isPresent,safeToRemove:safeToRemove})}},motion=function(createConfig){function custom(Component,customMotionComponentConfig={}){return function({preloadedFeatures,createVisualElement,projectionNodeConstructor,useRender,useVisualState,Component}){preloadedFeatures&&function(features){for(let key in features)"projectionNodeConstructor"===key?featureDefinitions.projectionNodeConstructor=features[key]:featureDefinitions[key].Component=features[key]}(preloadedFeatures);let ForwardRefComponent=(0,react.forwardRef)(function(props,externalRef){var visualElement,externalRef1;let configAndProps={...(0,react.useContext)(MotionConfigContext),...props,layoutId:function({layoutId}){let layoutGroupId=(0,react.useContext)(LayoutGroupContext).id;return layoutGroupId&&void 0!==layoutId?layoutGroupId+"-"+layoutId:layoutId}(props)},{isStatic}=configAndProps,features=null,context=function(props){let{initial,animate}=function(props,context){if(isControllingVariants(props)){let{initial,animate}=props;return{initial:!1===initial||isVariantLabel(initial)?initial:void 0,animate:isVariantLabel(animate)?animate:void 0}}return!1!==props.inherit?context:{}}(props,(0,react.useContext)(MotionContext));return(0,react.useMemo)(()=>({initial,animate}),[variantLabelsAsDependency(initial),variantLabelsAsDependency(animate)])}(props),projectionId=isStatic?void 0:useConstant(()=>{if(globalProjectionState.hasEverUpdated)return id++}),visualState=useVisualState(props,isStatic);if(!isStatic&&isBrowser){context.visualElement=function(Component,visualState,props,createVisualElement){let parent=(0,react.useContext)(MotionContext).visualElement,lazyContext=(0,react.useContext)(LazyContext),presenceContext=(0,react.useContext)(PresenceContext_PresenceContext),reducedMotionConfig=(0,react.useContext)(MotionConfigContext).reducedMotion,visualElementRef=(0,react.useRef)();createVisualElement=createVisualElement||lazyContext.renderer,!visualElementRef.current&&createVisualElement&&(visualElementRef.current=createVisualElement(Component,{visualState,parent,props,presenceId:presenceContext?presenceContext.id:void 0,blockInitialAnimation:!!presenceContext&&!1===presenceContext.initial,reducedMotionConfig}));let visualElement=visualElementRef.current;return useIsomorphicLayoutEffect(()=>{visualElement&&visualElement.render()}),(0,react.useEffect)(()=>{visualElement&&visualElement.animationState&&visualElement.animationState.animateChanges()}),useIsomorphicLayoutEffect(()=>()=>visualElement&&visualElement.notify("Unmount"),[]),visualElement}(Component,visualState,configAndProps,createVisualElement);let lazyStrictMode=(0,react.useContext)(LazyContext).strict,initialLayoutGroupConfig=(0,react.useContext)(SwitchLayoutGroupContext);context.visualElement&&(features=context.visualElement.loadFeatures(configAndProps,lazyStrictMode,preloadedFeatures,projectionId,projectionNodeConstructor||featureDefinitions.projectionNodeConstructor,initialLayoutGroupConfig))}return react.createElement(VisualElementHandler,{visualElement:context.visualElement,props:configAndProps},features,react.createElement(MotionContext.Provider,{value:context},useRender(Component,props,projectionId,(visualElement=context.visualElement,externalRef1=externalRef,(0,react.useCallback)(instance=>{instance&&visualState.mount&&visualState.mount(instance),visualElement&&(instance?visualElement.mount(instance):visualElement.unmount()),externalRef1&&("function"==typeof externalRef1?externalRef1(instance):isRefObject(externalRef1)&&(externalRef1.current=instance))},[visualElement])),visualState,isStatic,context.visualElement)))});return ForwardRefComponent[motionComponentSymbol]=Component,ForwardRefComponent}(createConfig(Component,customMotionComponentConfig))}if("undefined"==typeof Proxy)return custom;let componentCache=new Map;return new Proxy(custom,{get:(_target,key)=>(componentCache.has(key)||componentCache.set(key,custom(key)),componentCache.get(key))})}((Component,config)=>(function(Component,{forwardMotionProps=!1},preloadedFeatures,createVisualElement,projectionNodeConstructor){let baseConfig=isSVGComponent(Component)?svgMotionConfig:htmlMotionConfig;return{...baseConfig,preloadedFeatures,useRender:function(forwardMotionProps=!1){let useRender=(Component,props,projectionId,ref,{latestValues},isStatic)=>{let useVisualProps=isSVGComponent(Component)?useSVGProps:useHTMLProps,visualProps=useVisualProps(props,latestValues,isStatic),filteredProps=function(props,isDom,forwardMotionProps){let filteredProps={};for(let key in props)(shouldForward(key)||!0===forwardMotionProps&&isValidMotionProp(key)||!isDom&&!isValidMotionProp(key)||props.draggable&&key.startsWith("onDrag"))&&(filteredProps[key]=props[key]);return filteredProps}(props,"string"==typeof Component,forwardMotionProps),elementProps={...filteredProps,...visualProps,ref};return projectionId&&(elementProps["data-projection-id"]=projectionId),(0,react.createElement)(Component,elementProps)};return useRender}(forwardMotionProps),createVisualElement,projectionNodeConstructor,Component}})(Component,config,featureBundle,create_visual_element_createDomVisualElement,HTMLProjectionNode_HTMLProjectionNode))}}]);